
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='6', `category_id`='47', `title`='Hexo内嵌html或者Js代码遇到的问题', `summary`='在没有遇到这个坑之前我是完全不知道原来markdown里面是可以嵌入html或者js代码运行的。好吧是我孤陋寡闻了。在了解了原来还有这种操作的时候，整个人是惊呆了。，但想想也是，不然一个博客里面随随便便冒出一个button还能点击是怎么做出来的。', `status`='1', `weight`='0', `support`='0', `click`='293', `header_img`='img/pay.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p><br>在没有遇到这个坑之前我是完全不知道原来markdown里面是可以嵌入html或者js代码运行的。好吧是我孤陋寡闻了。在了解了原来还有这种操作的时候，整个人是惊呆了，但想想也是，不然一个博客里面随随便便冒出一个<code>button</code>还能点击是怎么做出来的。<br></p>\n<h1><a href=\"#进坑过程\" name=\"进坑过程\"></a>进坑过程</h1>\n<p><code>\n &lt;script type=\"text/javascript\"  alert(\"hello world！\");&gt;</code></p>\n<p>比如上面一段代码，写出来了，在<code>markdownpad</code>上面还是可以看到的，但是在<code>hexo</code>中就看不到了。此时脸上笑嘻嘻，心里***。（以上代码我是直接用``括起来的，如果没有扩起来的话，博文后面的内容是完全看不到的。）也是很奇怪这个东西，好像是因为hexo把MD文档全部按照它自己的语法编译了一次，这样就导致编译看起来效果不错，发布出去到处是坑。</p>\n<p>昨晚上我写了一篇博文，<code>hexo g</code>的时候就宝一大堆错，我尝试在其报错的位置进行解决，但是左看右看确实没错。原来是因为hexo文档中的有js代码，引起了连锁反应。毕竟hexo到现在虽然很不错了，但是还有些问题。 </p>\n<h1><a href=\"#脱坑过程\" name=\"脱坑过程\"></a>脱坑过程</h1>\n<p>遇事不决用谷歌，带着问题翻墙出去。结果发现没有人遇到和我一样的问题。难受。各个大佬群咨询，大佬们给出的建议都尝试了，还是没有办法。</p>\n<p>卸载重装，我就差换电脑了，哈哈哈。 </p>\n<p>好了，说下脱坑方法，在你的JS或者HTML代码前面加上4个空格，编译完美通过。</p>\n<p>记录下我的经历，方便以后遇到同样问题的兄弟。</p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>遇到问题不要慌。能够解决问题的程序员才是好程序员。不断的写bug，不断解决bug才是开发的乐趣。hexo是可以内嵌前端代码的，注意不要被这个坑了，好了，现在弄得差不多了，后面准备回归我的老本行了，写Android了。 </p>\n<p>最近新发现了一个markdown编辑器，还不错，如果不是因为不支持上传图片的话，我就转过去了。我也和开发的人聊了下，准备接入图床或者七牛云的接口。据说是hexo定制的，现在hexo的github主页就挂的这个编译器。有需要的可以去试试。 </p>\n<p>附上链接地址：<a href=\"https://github.com/zhuzhuyule/HexoEditor\">HEXOEditor </a> </p>\n<p>好了就到这里，踩了很多坑，不一一列出来了，大家有问题的话可以留言评论！</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:30:35' WHERE (`blog_id`='6');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='10', `category_id`='47', `title`='使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境', `summary`='在我的电脑上安装了MarkdownPad++还有VSCode（主要是用来写前端的），VSCode也是可以写md文章的。之所以之前我是安装了MarkdownPad++，是因为它有一个可以上传图片的功能，再加上它还有一些VSCode没有的快捷键，所以一直是两个软件并存，直到今天重新捣鼓了一下，终于可以去掉MarkdownPad++了。不得不说VSCode确实很强大，更加难得的是支持中文，这使我对这个软件的好感度哧溜的加加加。特写下这个教程，方便同样是我这种情况的朋友。', `status`='1', `weight`='0', `support`='0', `click`='148', `header_img`='img/pay.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#使用vscode-七牛云图床插件-自定义快捷键配置hexo博文编写环境\" name=\"使用vscode-七牛云图床插件-自定义快捷键配置hexo博文编写环境\"></a>使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境</h1>\n<h1>前言</h1><p><br></p><p>PS:本文图片失效，所有内容失效。</p><p><br></p>\n<p>在我的电脑上安装了MarkdownPad++还有VSCode（主要是用来写前端的），VSCode也是可以写md文章的。之所以之前我是安装了MarkdownPad++，是因为它有一个可以上传图片的功能，再加上它还有一些VSCode没有的快捷键，所以一直是两个软件并存，直到今天重新捣鼓了一下，终于可以去掉MarkdownPad++了。不得不说VSCode确实很强大，更加难得的是支持中文，这使我对这个软件的好感度哧溜的加加加。 </p>\n<p>特写下这个教程，方便同样是我这种情况的朋友。<br></p>\n<h1><a href=\"#过程\" name=\"过程\"></a>过程</h1>\n<ul>\n  <li>\n  <p>首先你得要有VSCode对吧，没有的话我也是附上链接：<a href=\"https://code.visualstudio.com/\">Go</a></p></li>\n  <li>\n  <p>其次是在VSCode中安装一个预览MD文件的插件<code>Markdown Preview Enhanced</code>，这样写文章的时候能够做到实时预览了。</p><p><br></p><p> </p></li>\n</ul>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155259.png\" alt=\"{mdFileName}-2018119155259\"></p>\n<ul>\n  <li>为了能够最大程度的获得一些markdown的通用快捷键，这里可以下载一个<code>Markdown Shortcuts</code>插件，比如Ctrl+l插入链接、Ctrl+B加粗之类的。</li>\n</ul>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155358.png\" alt=\"{mdFileName}-2018119155358\"> </p>\n<ul>\n  <li>\n    <p>最核心的一步——安装七牛云图床插件。</p>\n    <ul>\n      <li>\n      <p>安装插件<code>qiniu-upload-image</code>。<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155541.png\" alt=\"{mdFileName}-2018119155541\"></p></li>\n      <li>\n      <p>注册<a href=\"https://www.qiniu.com/\">七牛云</a>（注册后需要认证，我的认证时间是半天。）<br>接着在<img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916325.png\" alt=\"{mdFileName}-201811916325\">新建对象存储。这里会有一个默认的【测试域名】，如果你的网站还没有备案的话，就用这个默认的吧。备案了的可以自定义域名。</p></li>\n      <li>\n        <p>配置VSCode过程 </p>\n        <ul>\n          <li>依次打开【文件】-【首选项】-【设置】</li>\n          <li>在【搜索设置】中搜索<code>qiniu</code>关键字</li>\n          <li>将【qiniu configuration】中的6个子设置从【默认设置】拷贝到【用户设置】<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155911.png\" alt=\"{mdFileName}-2018119155911\"></li>\n          <li>其中的【AccessKey 签名授权】【SecretKey 签名授权】在<a href=\"https://portal.qiniu.com/user/key\">密钥管理</a></li>\n          <li>七牛图片上传空间是你的存储空间的名字，七牛图床域名为测试域名。</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>\n    <p>接着还想在VSCode里面直接完成部署功能。<br>有两种方法：</p>\n    <ul>\n      <li>1 安装<code>vscode-Hexo</code>插件 然后直接在命令面板中输入以下命令：<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916939.png\" alt=\"{mdFileName}-201811916939\"></li>\n      <li>2 按住Ctrl+` 在VSCode中弹出终端，也可以在这里面直接输入命令操作。<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119161338.png\" alt=\"{mdFileName}-2018119161338\"></li>\n    </ul>\n  </li>\n</ul>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>卸载掉MarkdownPad ，电脑又轻松了几百M。如果需要帮助的盆友请留言。</p>\n<p>2018年5月29日12:32:48更新</p>\n<p>最近收到读者给我发的邮件说会出现如下情况：</p>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/QQ截图20180529123226.png\" alt=\"QQ截图20180529123226\"></p>\n<p>经过研究，这里出现的原因是因为快捷键冲突，因为七牛云的插件的默认设置是：</p>\n<p><em>粘贴图片路径上传：SHIFT + P<br>直接选择图片上传：SHIFT + O</em></p>\n<p>所以，在设置里面更改快捷键，比如我相关**Ctrl+G**表示上传图片。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:35:58' WHERE (`blog_id`='10');


INSERT INTO `dimple_blog`.`bg_carousel_map` (`carousel_id`, `img_url`, `title`, `sub_title`, `display`, `url`, `target`, `click`, `create_time`, `create_by`, `update_by`, `update_time`) VALUES ('2', 'img/1505212629.jpg', '最新电影', '好看', '1', 'img/1505212629.jpg', '1', '0', '2019-05-05 21:30:10', NULL, NULL, NULL);
INSERT INTO `dimple_blog`.`bg_carousel_map` (`carousel_id`, `img_url`, `title`, `sub_title`, `display`, `url`, `target`, `click`, `create_time`, `create_by`, `update_by`, `update_time`) VALUES ('3', 'img/220190505212655.jpg', '复仇者联盟', '很好看啦', '1', 'img/220190505212655.jpg', '1', '1', '2019-05-05 21:30:56', NULL, NULL, NULL);
UPDATE `dimple_blog`.`bg_carousel_map` SET `carousel_id`='1', `img_url`='img/login-background.jpg', `title`='Spring 常用注解', `sub_title`='21321', `display`='1', `url`='21', `target`='1', `click`='1111', `create_time`=NULL, `create_by`=NULL, `update_by`=NULL, `update_time`='2019-04-08 17:29:57' WHERE (`carousel_id`='1');
UPDATE `dimple_blog`.`bg_carousel_map` SET `carousel_id`='1', `img_url`='img/657b07046abc1a8dd3de65ea80f37ded.jpg', `title`='Spring 常用注解', `sub_title`='21321', `display`='1', `url`='21', `target`='1', `click`='1111', `create_time`=NULL, `create_by`=NULL, `update_by`=NULL, `update_time`='2019-04-08 17:29:57' WHERE (`carousel_id`='1');
UPDATE `dimple_blog`.`bg_carousel_map` SET `carousel_id`='2', `img_url`='img/330798-1F41111104993.jpg', `title`='最新电影', `sub_title`='好看', `display`='1', `url`='img/1505212629.jpg', `target`='1', `click`='0', `create_time`='2019-05-05 21:30:10', `create_by`=NULL, `update_by`=NULL, `update_time`=NULL WHERE (`carousel_id`='2');
UPDATE `dimple_blog`.`bg_carousel_map` SET `carousel_id`='3', `img_url`='img/ced846eab08578468670a87333e05b5f.jpg', `title`='复仇者联盟', `sub_title`='很好看啦', `display`='1', `url`='img/220190505212655.jpg', `target`='1', `click`='1', `create_time`='2019-05-05 21:30:56', `create_by`=NULL, `update_by`=NULL, `update_time`=NULL WHERE (`carousel_id`='3');



UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='6', `category_id`='47', `title`='Hexo内嵌html或者Js代码遇到的问题', `summary`='在没有遇到这个坑之前我是完全不知道原来markdown里面是可以嵌入html或者js代码运行的。好吧是我孤陋寡闻了。在了解了原来还有这种操作的时候，整个人是惊呆了。，但想想也是，不然一个博客里面随随便便冒出一个button还能点击是怎么做出来的。', `status`='1', `weight`='0', `support`='0', `click`='293', `header_img`='/img/pay.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p><br>在没有遇到这个坑之前我是完全不知道原来markdown里面是可以嵌入html或者js代码运行的。好吧是我孤陋寡闻了。在了解了原来还有这种操作的时候，整个人是惊呆了，但想想也是，不然一个博客里面随随便便冒出一个<code>button</code>还能点击是怎么做出来的。<br></p>\n<h1><a href=\"#进坑过程\" name=\"进坑过程\"></a>进坑过程</h1>\n<p><code>\n &lt;script type=\"text/javascript\"  alert(\"hello world！\");&gt;</code></p>\n<p>比如上面一段代码，写出来了，在<code>markdownpad</code>上面还是可以看到的，但是在<code>hexo</code>中就看不到了。此时脸上笑嘻嘻，心里***。（以上代码我是直接用``括起来的，如果没有扩起来的话，博文后面的内容是完全看不到的。）也是很奇怪这个东西，好像是因为hexo把MD文档全部按照它自己的语法编译了一次，这样就导致编译看起来效果不错，发布出去到处是坑。</p>\n<p>昨晚上我写了一篇博文，<code>hexo g</code>的时候就宝一大堆错，我尝试在其报错的位置进行解决，但是左看右看确实没错。原来是因为hexo文档中的有js代码，引起了连锁反应。毕竟hexo到现在虽然很不错了，但是还有些问题。 </p>\n<h1><a href=\"#脱坑过程\" name=\"脱坑过程\"></a>脱坑过程</h1>\n<p>遇事不决用谷歌，带着问题翻墙出去。结果发现没有人遇到和我一样的问题。难受。各个大佬群咨询，大佬们给出的建议都尝试了，还是没有办法。</p>\n<p>卸载重装，我就差换电脑了，哈哈哈。 </p>\n<p>好了，说下脱坑方法，在你的JS或者HTML代码前面加上4个空格，编译完美通过。</p>\n<p>记录下我的经历，方便以后遇到同样问题的兄弟。</p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>遇到问题不要慌。能够解决问题的程序员才是好程序员。不断的写bug，不断解决bug才是开发的乐趣。hexo是可以内嵌前端代码的，注意不要被这个坑了，好了，现在弄得差不多了，后面准备回归我的老本行了，写Android了。 </p>\n<p>最近新发现了一个markdown编辑器，还不错，如果不是因为不支持上传图片的话，我就转过去了。我也和开发的人聊了下，准备接入图床或者七牛云的接口。据说是hexo定制的，现在hexo的github主页就挂的这个编译器。有需要的可以去试试。 </p>\n<p>附上链接地址：<a href=\"https://github.com/zhuzhuyule/HexoEditor\">HEXOEditor </a> </p>\n<p>好了就到这里，踩了很多坑，不一一列出来了，大家有问题的话可以留言评论！</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:30:35' WHERE (`blog_id`='6');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='10', `category_id`='47', `title`='使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境', `summary`='在我的电脑上安装了MarkdownPad++还有VSCode（主要是用来写前端的），VSCode也是可以写md文章的。之所以之前我是安装了MarkdownPad++，是因为它有一个可以上传图片的功能，再加上它还有一些VSCode没有的快捷键，所以一直是两个软件并存，直到今天重新捣鼓了一下，终于可以去掉MarkdownPad++了。不得不说VSCode确实很强大，更加难得的是支持中文，这使我对这个软件的好感度哧溜的加加加。特写下这个教程，方便同样是我这种情况的朋友。', `status`='1', `weight`='0', `support`='0', `click`='148', `header_img`='/img/pay.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#使用vscode-七牛云图床插件-自定义快捷键配置hexo博文编写环境\" name=\"使用vscode-七牛云图床插件-自定义快捷键配置hexo博文编写环境\"></a>使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境</h1>\n<h1>前言</h1><p><br></p><p>PS:本文图片失效，所有内容失效。</p><p><br></p>\n<p>在我的电脑上安装了MarkdownPad++还有VSCode（主要是用来写前端的），VSCode也是可以写md文章的。之所以之前我是安装了MarkdownPad++，是因为它有一个可以上传图片的功能，再加上它还有一些VSCode没有的快捷键，所以一直是两个软件并存，直到今天重新捣鼓了一下，终于可以去掉MarkdownPad++了。不得不说VSCode确实很强大，更加难得的是支持中文，这使我对这个软件的好感度哧溜的加加加。 </p>\n<p>特写下这个教程，方便同样是我这种情况的朋友。<br></p>\n<h1><a href=\"#过程\" name=\"过程\"></a>过程</h1>\n<ul>\n  <li>\n  <p>首先你得要有VSCode对吧，没有的话我也是附上链接：<a href=\"https://code.visualstudio.com/\">Go</a></p></li>\n  <li>\n  <p>其次是在VSCode中安装一个预览MD文件的插件<code>Markdown Preview Enhanced</code>，这样写文章的时候能够做到实时预览了。</p><p><br></p><p> </p></li>\n</ul>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155259.png\" alt=\"{mdFileName}-2018119155259\"></p>\n<ul>\n  <li>为了能够最大程度的获得一些markdown的通用快捷键，这里可以下载一个<code>Markdown Shortcuts</code>插件，比如Ctrl+l插入链接、Ctrl+B加粗之类的。</li>\n</ul>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155358.png\" alt=\"{mdFileName}-2018119155358\"> </p>\n<ul>\n  <li>\n    <p>最核心的一步——安装七牛云图床插件。</p>\n    <ul>\n      <li>\n      <p>安装插件<code>qiniu-upload-image</code>。<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155541.png\" alt=\"{mdFileName}-2018119155541\"></p></li>\n      <li>\n      <p>注册<a href=\"https://www.qiniu.com/\">七牛云</a>（注册后需要认证，我的认证时间是半天。）<br>接着在<img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916325.png\" alt=\"{mdFileName}-201811916325\">新建对象存储。这里会有一个默认的【测试域名】，如果你的网站还没有备案的话，就用这个默认的吧。备案了的可以自定义域名。</p></li>\n      <li>\n        <p>配置VSCode过程 </p>\n        <ul>\n          <li>依次打开【文件】-【首选项】-【设置】</li>\n          <li>在【搜索设置】中搜索<code>qiniu</code>关键字</li>\n          <li>将【qiniu configuration】中的6个子设置从【默认设置】拷贝到【用户设置】<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155911.png\" alt=\"{mdFileName}-2018119155911\"></li>\n          <li>其中的【AccessKey 签名授权】【SecretKey 签名授权】在<a href=\"https://portal.qiniu.com/user/key\">密钥管理</a></li>\n          <li>七牛图片上传空间是你的存储空间的名字，七牛图床域名为测试域名。</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>\n    <p>接着还想在VSCode里面直接完成部署功能。<br>有两种方法：</p>\n    <ul>\n      <li>1 安装<code>vscode-Hexo</code>插件 然后直接在命令面板中输入以下命令：<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916939.png\" alt=\"{mdFileName}-201811916939\"></li>\n      <li>2 按住Ctrl+` 在VSCode中弹出终端，也可以在这里面直接输入命令操作。<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119161338.png\" alt=\"{mdFileName}-2018119161338\"></li>\n    </ul>\n  </li>\n</ul>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>卸载掉MarkdownPad ，电脑又轻松了几百M。如果需要帮助的盆友请留言。</p>\n<p>2018年5月29日12:32:48更新</p>\n<p>最近收到读者给我发的邮件说会出现如下情况：</p>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/QQ截图20180529123226.png\" alt=\"QQ截图20180529123226\"></p>\n<p>经过研究，这里出现的原因是因为快捷键冲突，因为七牛云的插件的默认设置是：</p>\n<p><em>粘贴图片路径上传：SHIFT + P<br>直接选择图片上传：SHIFT + O</em></p>\n<p>所以，在设置里面更改快捷键，比如我相关**Ctrl+G**表示上传图片。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:35:58' WHERE (`blog_id`='10');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='3', `category_id`='50', `title`='Android Studio 优化', `summary`='安装好Android Studio之后需要根据自己的习惯进行一些设置，下载些插件、设置下软件的相关属性等等。刚好重装了下系统，针对这个Android Studio进行了相关的设置，在这里将经历说一下，避免自己以后晚了相关设置也方便一些需要帮助的朋友', `status`='1', `weight`='0', `support`='0', `click`='174', `header_img`='/img/330798-1F41111104993.jpg', `type`='2', `content`='<p><br></p>\n<blockquote>\n  <p><em>安装好Android Studio之后需要根据自己的习惯进行一些设置，下载些插件、设置下软件的相关属性等等。刚好重装了下系统，针对这个Android Studio进行了相关的设置，在这里将经历说一下，避免自己以后晚了相关设置也方便一些需要帮助的朋友</em> </p>\n</blockquote>\n<p>更新记录：2017年12月24日22:32:37更新<br><br>本文主要分为设置篇和插件篇： </p>\n<h1><a href=\"#技巧篇\" name=\"技巧篇\"></a>技巧篇</h1>\n<p>##快速查找以及快捷键搜索<br>在AS的面板上双击<code>shift</code>键，即可调出全局搜索。</p>\n<p><img src=\"http://img.blog.csdn.net/20171224213924058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>AS有很多的快捷键，对于这些快捷键你不一定随时都能记得，这个时候可以使用<code>Win+Shift+A</code>键输入你想用的功能。后面会提示相关的快捷键的。<br><img src=\"http://img.blog.csdn.net/20171224214158337?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n<h2><a href=\"#恢复默认布局\" name=\"恢复默认布局\"></a>恢复默认布局</h2>\n<p>当你各种乱动默认的面板布局的时候，有的面板你想找的时候却发现找不到了，这个时候按住 <code>Shift+F12</code>就可以重置默认面板。<br><img src=\"http://img.blog.csdn.net/20171224214521926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n<h2><a href=\"#tip-of-the-day\" name=\"tip-of-the-day\"></a>Tip of the day</h2>\n<p>打开软件的时候随机显示关于Android Studio的相关使用提示。（很有用的，别关）</p>\n<p><img src=\"http://img.blog.csdn.net/20171224215949578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2><a href=\"#android-studio相关网站\" name=\"android-studio相关网站\"></a>Android Studio相关网站</h2>\n<ul>\n  <li><a href=\"http://www.android-studio.org/\">Android Studio 中文社区</a></li>\n  <li><a href=\"https://stackoverflow.com/\">优质的问答社区（英文的）</a></li>\n</ul>\n<h1><a href=\"#设置篇\" name=\"设置篇\"></a>设置篇</h1>\n<blockquote>\n  <p>Android Studio到底是外国人开发的，这个东西拿到手感觉和我们日常使用的IDE有点···· </p>\n</blockquote>\n<h2><a href=\"#鼠标滚轮滑动调整字体大小\" name=\"鼠标滚轮滑动调整字体大小\"></a>鼠标滚轮滑动调整字体大小</h2>\n<p>打开<code>File</code>里的<code>Setting</code> 勾选<code>Change font size(Zoom)with Ctrl——Mouse Wheel</code><br><img src=\"http://img.blog.csdn.net/20171224214754310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n<h2><a href=\"#查看参数定义\" name=\"查看参数定义\"></a>查看参数定义</h2>\n<p>使用快捷键<code>Ctrl+P</code>可以查看当前鼠标所在位置的方法的参数定义。<br><img src=\"http://img.blog.csdn.net/20171224222531022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n<h2><a href=\"#鼠标移动显示api文档\" name=\"鼠标移动显示api文档\"></a>鼠标移动显示API文档</h2>\n<p>设置当鼠标移动到方法上的时候显示API文档。<code>Editor-&gt;General-&gt;show quick document on mouse move</code> 后面那个Delay Time 是设置延时的，单位为毫秒。但是建议电脑性能差一点的不要开，会很卡。<br><img src=\"http://img.blog.csdn.net/20171224222926874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2><a href=\"#设置默认的字体大小\" name=\"设置默认的字体大小\"></a>设置默认的字体大小</h2>\n<p>打开AS的时候发现蚊子一样大小的代码，密密麻麻的密集恐惧症受不了。<code>Editor-&gt;Colors&amp;Fonts-&gt;Font</code><br>一般设置到18就行了<br><img src=\"http://img.blog.csdn.net/20171224215037079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n<h2><a href=\"#更改快捷键\" name=\"更改快捷键\"></a>更改快捷键</h2>\n<p>设置<code>Keymap</code>，快捷键太多，可以使用搜索框搜索 </p>\n<p><img src=\"http://img.blog.csdn.net/20171224220232053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2><a href=\"#设置代码提示\" name=\"设置代码提示\"></a>设置代码提示</h2>\n<p>Android Studio的代码提示是对大小写敏感的，选择None就可以匹配到很多方法或者关键字，这个在你忘了这个方法怎么写的时候非常有用。<br>此外**Ctrl+Q**快捷键也可以设置代码提示。<br><img src=\"http://img.blog.csdn.net/20171224220954002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>## 去掉代码编辑区的竖线 </p>\n<p>编辑区域总是有一条竖线，这条竖线的作用是用来警示程序员代码不要写的过长的。<br> <img src=\"http://p2sj58chj.bkt.clouddn.com/QQ截图20180320143743.png\" alt=\"QQ截图20180320143743\"> </p>\n<p>## 设置方法之间横线隔开<br>操作方法如图：勾选 <strong>Show method separators</strong></p>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/QQ截图20180320143838.png\" alt=\"QQ截图20180320143838\"> </p>\n<h2><a href=\"#炫酷的log\" name=\"炫酷的log\"></a>炫酷的Log</h2>\n<p>设置地址：Preferences → Editor → Colors &amp; Fonts → Android Logcat<br>将各种类型的log设置颜色：<br>参考别人的配色如下：附上<a href=\"https://meedamian.com/post/deuglifying-android-studio/\">链接</a></p>\n<p>Type Color<br>verbose: #BBB<br>debug: #33B5E5<br>info: #9C0<br>assert: #A6C<br>error: #F44<br>warning: #FB3<br> <br>效果如下：<br><img src=\"http://p2sj58chj.bkt.clouddn.com/QQ截图20180320150409.png\" alt=\"QQ截图20180320150409\"></p>\n<h1><a href=\"#插件篇\" name=\"插件篇\"></a>插件篇</h1>\n<h2><a href=\"#androidaccessors\" name=\"androidaccessors\"></a>AndroidAccessors</h2>\n<p>快速生成<code>get</code>和<code>set</code>系列方法。这个在你定义<code>JavaBean</code>的时候非常有用。<br><img src=\"http://img.blog.csdn.net/20171224221252982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n<h2><a href=\"#butterknifezelezny-插件\" name=\"butterknifezelezny-插件\"></a>ButterKnifeZelezny 插件</h2>\n<p>如果你厌倦了findViewById这样的写法，那么这个插件是你的选择。这个配合ButterKnife使用的。</p>\n<h2><a href=\"#recitewords\" name=\"recitewords\"></a>ReciteWords</h2>\n<p>是一个IntelliJ IDEA、Android Studio 记单词翻译插件,可以将英文翻译为中文并记录到生词本提供查阅。，项目地址为：<a href=\"https://github.com/BolexLiu/ReciteWords\">ReciteWords</a></p>\n<p>功能： </p>\n<ul>\n  <li>划词翻译 整句翻译 拆分驼峰命名翻译等</li>\n  <li>生词本保存翻译过后的历史记录</li>\n</ul>\n<p>使用方法： </p>\n<ul>\n  <li>\n  <p>Clone项目，获取根目录下的ReciteWords.jar。</p></li>\n  <li>\n  <p>打开Android Studio， Preferences -&gt; Plugins -&gt; Install plugin from disk -&gt; 获取ReciteWords.jar安装并重启Android Studio。</p></li>\n  <li>\n  <p>选中代码，按下 Alt+Q(也可以自己设定)。即可翻译。效果如下:<br><img src=\"https://github.com/BolexLiu/ReciteWords/raw/master/img/1.png\"></p></li>\n  <li>\n  <p>设置快捷键<br>使用键盘快捷键触发，Preferences -&gt; Keymap -&gt; 获取ReciteWords - &gt; 右键 add Keyboard Shortcut. 输入你想要的快捷键即可。</p></li>\n</ul>\n<h2><a href=\"#主题\" name=\"主题\"></a>主题</h2>\n<p>这里我推荐一个<code>MaterialDesign AS UI Theme</code> 这个主题比较好用，尤其是配合黑色的AS主题的时候。</p>\n<p>顺便推荐一个http://color-themes.com/ 这个网站下载你喜欢的主题，然后导入主题即可。<br><img src=\"http://img.blog.csdn.net/20171224222110962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>插件及常用的快捷键请看我之前的博客：http://blog.csdn.net/qq_32454537/article/details/77870200</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:10:57' WHERE (`blog_id`='3');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='12', `category_id`='52', `title`='Android BroadcastReceiver 的静态动态注册及区别', `summary`='为了方便Android系统各个应用程序及程序内部进行通信，Android系统引入了一套广播机制。各个应用程序可以对感兴趣的广播进行注册，当系统或者其他程序发出这条广播的时候，对发出的广播进行注册的程序便能够收到这条广播。为此，Android系统中有一套完整的API，允许程序只有的发送和接受广播。本文会分别介绍静态注册广播和动态注册广播的方法并比较这两种的区别。', `status`='1', `weight`='0', `support`='0', `click`='180', `header_img`='/img/330798-1F41111104993.jpg', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>为了方便Android系统各个应用程序及程序内部进行通信，Android系统引入了一套广播机制。各个应用程序可以对感兴趣的广播进行注册，当系统或者其他程序发出这条广播的时候，对发出的广播进行注册的程序便能够收到这条广播。为此，Android系统中有一套完整的API，允许程序只有的发送和接受广播。<br>本文会分别介绍静态注册广播和动态注册广播的方法并比较这两种的区别。<br><br><strong>在此会先说明发送广播的两种方法</strong></p>\n<h1><a href=\"#广播两种基本类型\" name=\"广播两种基本类型\"></a>广播两种基本类型</h1>\n<p>在一个程序中，可以发送广播供当前程序的广播接收器收到。首先我们来看下两种方式的发送广播。<br>在Android系统中，主要有两种基本的广播类型：<br>- 标准广播（Normal Broadcasts）<br>- 有序广播（Ordered Broadcasts） </p>\n<h2><a href=\"#标准广播\" name=\"标准广播\"></a>标准广播</h2>\n<p>是一种完全异步执行的广播，在广播发出之后，所有的广播接收器会在同一时间接收到这条广播，广播无法被截断。 </p>\n<p>发送广播的方式十分简单，只需要实例化一个**Intent**对象，然后调用**context**的** sendBroadcast() **方法。 </p>\n<pre><code>        //intent中的参数为action\n        Intent intent=new Intent(\"com.example.dimple.BROADCAST_TEST\");\n        sendBroadcast(intent);\n</code></pre>\n<p>这样就完成了广播的发送，至于接收呢，需要用到广播接收器，这个下面会写到。 </p>\n<h2><a href=\"#有序广播\" name=\"有序广播\"></a>有序广播</h2>\n<p>是一种同步执行的广播，在广播发出之后，优先级高的广播接收器可以优先接收到这条广播，并可以在优先级较低的广播接收器之前截断停止发送这条广播。 </p>\n<p>至于有序广播： </p>\n<pre><code>        //intent中的参数为action\n        Intent intent=new Intent(\"com.example.dimple.BROADCAST_TEST\");\n        sendOrderBroadcast(intent，null);//第二个参数是与权限相关的字符串。\n</code></pre>\n<p>到此时，如果你的程序中只有一个广播接收器的话，是体现不出有序广播的特点的，<br>右击包名——New——Other——BroadcastReceiver多创建几个广播接收器。 </p>\n<p>此时你还是会发现，所有的广播接收器是同时接收到广播消息的。注意上面介绍的时候说到优先级，这个时候我们需要设置优先级，在AndroidManifest文件中的Receiver标签中设置广播接收器的优先级。 </p>\n<pre><code>        &lt;receiver\n            android:name=\".MyReceiver\"\n            android:enabled=\"true\"\n            android:exported=\"true\"&gt;\n            &lt;!--注意此时有一个Priority属性--&gt;\n            &lt;intent-filter android:priority=\"100\"&gt;\n                &lt;action android:name=\"android.intent.action.BROADCAST_TEST\"&gt;&lt;/action&gt;\n            &lt;/intent-filter&gt;\n        &lt;/receiver&gt;\n</code></pre>\n<p>优先级越高的广播接收器可以先收到广播，也可以在收到广播的时候调用**abortBroadcast()**方法截断广播。优先级低的广播接收器就无法接收到广播了。</p>\n<h1><a href=\"#注册广播\" name=\"注册广播\"></a>注册广播</h1>\n<h2><a href=\"#自定义broadcastreceiver\" name=\"自定义broadcastreceiver\"></a>自定义BroadcastReceiver</h2>\n<p>在Android的广播接收机制中，如果需要接收广播，就需要创建广播接收器。而创建广播接收器的方法就是**新建一个类（可以是单独新建类，也可以是内部类（public））** 继承自**BroadcastReceiver** </p>\n<pre><code>   class myBroadcastReceiver extends BroadcastReceiver{\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            //接收到广播的处理，注意不能有耗时操作，当此方法长时间未结束，会报错。\n            //同时，广播接收器中不能开线程。\n        }\n    } \n\n</code></pre>\n<h2><a href=\"#两种注册方法\" name=\"两种注册方法\"></a>两种注册方法</h2>\n<h3><a href=\"#动态注册\" name=\"动态注册\"></a>动态注册</h3>\n<p>所谓动态注册是指在代码中注册。步骤如下 ：<br>- 实例化自定义的广播接收器。<br>- 创建**IntentFilter**实例。<br>- 调用**IntentFilter**实例的**addAction()**方法添加监听的广播类型。<br>- 最后调用**Context**的**registerReceiver(BroadcastReceiver,IntentFilter)**动态的注册广播。 </p>\n<p>此时，已经为我们自定义的广播接收器绑定了广播，当收到和绑定的广播一直的广播的时候，就会调用广播接收器中的**onReceiver**方法。 </p>\n<pre><code>        MyBroadcastReceiver myBroadcastReceiver=new MyBroadcastReceiver();\n        IntentFilter intentFilter=new IntentFilter();\n        intentFilter.addAction(\"com.example.dimple.MY_BROADCAST\");\n        registerReceiver(myBroadcastReceiver,intentFilter);\n</code></pre>\n<p>PS:这里提醒一点，如果需要接收系统的广播（比如电量变化，网络变化等等），别忘记在AndroidManifest配置文件中加上权限。 </p>\n<p>另外，动态注册的广播在活动结束的时候需要取消注册： </p>\n<pre><code>    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unregisterReceiver(myBroadcastReceiver);\n    }  \n</code></pre>\n<h3><a href=\"#静态注册\" name=\"静态注册\"></a>静态注册</h3>\n<p>这里我们使用静态注册来接收开机广播。<br>使用Android Studio 中的快捷方法来创建广播接收器。 </p>\n<p>右击包名——New——Other——BroadcastReceiver。 </p>\n<p><br></p><p><img src=\"http://images.bianxiaofeng.com/0a57cd5786f277552c214d355a3f840f.png\" style=\"\"><br></p><p> </p>\n<p>PS：静态注册的广播接收器需要在AndroidManifest文件中注册，由于使用的AS的快捷方式，所以已经创建好了。<br>如图所示：</p><p><br></p><p><img src=\"http://images.bianxiaofeng.com/a9c64edbbae3798c65dd510777d11596.png\" style=\"\"><br></p>\n<p>在创建好的广播接收器中添加一个Toast提示。代码如下： </p>\n<pre><code class=\"public class MyReceiver extends BroadcastReceiver {\">    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,\"开机启动！\",Toast.LENGTH_LONG).show();\n    }  \n}```\n    \n然后在AndroidManifest文件中添加：  \n\n- 权限  \n`&lt;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"&gt;&lt;/uses-permission&gt; `    \n\n- Intent-filter  \n\n</code></pre>\n<pre><code>    &lt;receiver\n        android:name=\".MyReceiver\"\n        android:enabled=\"true\"\n        android:exported=\"true\"&gt;\n        &lt;!--添加以下3行--&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\"&gt;&lt;/action&gt;\n        &lt;/intent-filter&gt;\n    &lt;/receiver&gt;\n</code></pre>\n<p>```</p>\n<p>此时重启Android系统就可以收到开机提示了。 </p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>动态注册和静态注册的区别： </p>\n<ul>\n  <li>\n  <p>动态注册的广播接收器可以自由的控制注册和取消，有很大的灵活性。但是只能在程序启动之后才能收到广播，此外，不知道你注意到了没，广播接收器的注销是在onDestroy()方法中的。所以广播接收器的生命周期是和当前活动的生命周期一样。</p></li>\n  <li>\n  <p>静态注册的广播不受程序是否启动的约束，当应用程序关闭之后，还是可以接收到广播。</p></li>\n</ul>\n<p>标准广播和有序广播的接收和发送都是全局性的，这样会使得其他程序有可能接收到广播，会造成一定的安全隐患。为了解决这个问题，Android系统中有一套本地广播的机制。这个机制是让所有的广播事件（接收与发送）都在程序内部完成。主要是采用的一个<b>localBroadcastReceiver</b>对广播进行管理。 </p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:36:34' WHERE (`blog_id`='12');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='14', `category_id`='52', `title`='Android Activity的启动模式', `summary`='当用户多次启动同一个Activity的时候，系统默认会一直为这个Activity创建实例，并将实例放入任务栈中，在用户按back键的时候会一一回退，每按一次任务栈的时候，栈顶的任务就会出栈，当任务栈为空的时候系统会回收这个任务栈。这就是在默认的情况下，系统对于Activity的处理方式。而这种默认的方式在某些时候可能不太符合开发者的意图。所以Android出现了多种的启动模式和标志位来更改这一默认的行为。', `status`='1', `weight`='0', `support`='0', `click`='188', `header_img`='/img/330798-1F41111104993.jpg', `type`='2', `content`='<p><span style=\"color: inherit; font-family: inherit; font-size: 30px;\">前言</span><br></p>\n<p>当用户多次启动同一个Activity的时候，系统默认会一直为这个Activity创建实例，并将实例放入任务栈中，在用户按back键的时候会一一回退，每按一次任务栈的时候，栈顶的任务就会出栈，当任务栈为空的时候系统会回收这个任务栈。这就是在默认的情况下，系统对于Activity的处理方式。而这种默认的方式在某些时候可能不太符合开发者的意图。所以Android出现了多种的启动模式和标志位来更改这一默认的行为。<br></p>\n<h1><a href=\"#activity的launchmode\" name=\"activity的launchmode\"></a>Activity的LaunchMode</h1>\n<p>目前有四种LaunchMode，分别是：standard、singleTop、singleTask以及singleInstance。<br>为了方便说明和解释，我这里写了一个Demo，以上传到GitHub，详情请<a href=\"https://github.com/DimpleFeng/Android-Activity-LaunchMode\">点击</a>。界面如下：<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155052.png\" alt=\"{mdFileName}-201837155052\"><br>分别对应4种状态的LaunchMode。</p>\n<h2><a href=\"#standard-launchmode\" name=\"standard-launchmode\"></a>standard LaunchMode</h2>\n<p>标准模式，这是系统默认的模式，每次启动的Activity的时候会默认创建一个实例，不管这个实例是不是存在。被创建的Activity实例符合典型情况下的生命周期。<br>在这种情况下，谁启动了这个Activity，那么这个Activity就属于启动它的Activity的任务栈中。比如： A启动了B，那么B就属于A的任务栈的成员。 </p>\n<p>Demo点击第一项按钮4下结果如下：<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837123217.png\" alt=\"{mdFileName}-201837123217\"><br>可以看到：<br>这里依次调用了4次的onCreate，且每次的hashcode都不一样。说明分别创建了4次Activity实例。而且任务栈的ID一直都是88.这也就说明了**谁启动Activity，该Activity就位于哪个任务栈中的说法**。</p>\n<h2><a href=\"#singletop-launchmode\" name=\"singletop-launchmode\"></a>singleTop LaunchMode</h2>\n<p>栈顶复用模式。在这种模式下，如果新的Activity已经处于任务栈的栈顶，那么这个Activity将不会被创建。同时，它的onNewIntent方法会被回调，通过此方法就可以取出当前请求的信息。但是如果新的Activity不是位于栈顶，那么这个Activity会被实例化。<br>比如： 一个任务栈中从栈顶到栈底的Activity顺序是：ABCD，如果需要启动任务A，任务A的启动模式为singleTop，那么这个A不会被实例化，而是会调用onNewIntent方法。如果需要启动B，任务B的启动模式为singleTop，那么由于B不在栈顶，那么依然会实例化B，此时任务栈的顺序是：BABCD。 </p>\n<p>Demo第二项点击4下Log如图所示：<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155237.png\" alt=\"{mdFileName}-201837155237\"><br>可以看到：<br>只第一次点击的时候调用了onCreate方法，之后便是调用的onNewIntent方法。而且hashcode都是一样的。这就说明：**新的Activity如果位于栈顶，那么新的Activity不会被实例化。**</p>\n<h2><a href=\"#singletask-launchmode\" name=\"singletask-launchmode\"></a>singleTask LaunchMode</h2>\n<p>栈内复用模式。在这种模式下，只要Activity在任务栈中存在，那么就不会重新创建实例，和singleTop一样，系统会自动回调onNewIntent方法。<br>比如：当前任务栈中有ABCD四个Activity，需要启动一个Activity C，这个时候任务栈中有Activity C，那么会直接将Activity C调到栈顶，同时回调onNewIntent方法，**由于singleTask具有cleanTop的效果**，所以此时的任务栈的Activity为CD。如果需要启动Activity F，而Activity F不存在，所以会直接实例化Activity F，并压入栈顶。 </p>\n<p>log截图如下： </p>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155659.png\" alt=\"{mdFileName}-201837155659\"> </p>\n<p>这里的操作步骤是：<br>点击进入到singleTask界面，此时出现第一个onCreate，然后点击进入到其他Activity，出现第二个onCrete。此时应该注意到，任务栈的栈顶是其他Activity，这个时候在其他Activity点击返回到singTask。由于采用的是singleTask模式，singleTask已经在任务栈中，所以是直接调用，回调onNewIntent。 </p>\n<p><strong>而且由于cleanTop效果，按返回键的时候，其他Activity是不会再出现的。</strong>这一点的话，在BaseActivity.java中重写生命周期的方法就能看出来。 </p>\n<h2><a href=\"#singleinstance-launchmode\" name=\"singleinstance-launchmode\"></a>singleInstance LaunchMode</h2>\n<p>单实例模式。这是一种加强的singleTask模式，具有singleTask的所有特性（cleanTop等），还有一点：使用这种模式的Activity只能单独的位于一个单独的任务栈中。<br>比如：Activity A是singleInstance模式，当A启动后，系统会单独为这个A创建一个任务栈，由于栈内复用的原因，不会再创建新的Activity A的实例。<br><img src=\"http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018371622.png\" alt=\"{mdFileName}-2018371622\"><br>由于这个是单实例模式，对于同一个Activity来说，是直接复用。 </p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>TaskAffinity，任务相关性，这个参数标识了一个Activity需要的任务栈的名字，在默认情况下，这个任务栈的名字为应用的包名。任务栈分为前台任务栈和后台任务栈。位于后台任务栈的Activity是处于暂停状态。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:27:26' WHERE (`blog_id`='14');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='15', `category_id`='52', `title`='Android InterFilter 匹配', `summary`='一般来说，启动Activity的方法有两种，显式启动和隐式启动。对于显示启动来说，只需要实例化一个Intent对象，指明被启动对象的组件信息，包括包名以及类名。例如', `status`='1', `weight`='0', `support`='0', `click`='190', `header_img`='/img/330798-1F41111104993.jpg', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>一般来说，启动Activity的方法有两种，显式启动和隐式启动。对于显示启动来说，只需要实例化一个Intent对象，指明被启动对象的组件信息，包括包名以及类名。例如 </p>\n<pre><code>Intent intent=new Intent(MainActivity.this,OtherActivity.class);\n</code></pre>\n<p>原则上是单独的使用隐式启动和显式启动，如果两者并存的话，以显式启动为准。<br>隐式调用需要Intent能够匹配目标组件的IntentFilter设置的过滤信息，如果不匹配的话是不能正常的启动Activity。Intent中需要过滤的信息包括：action、category和data。 </p>\n<h1><a href=\"#intentfilter的匹配规则\" name=\"intentfilter的匹配规则\"></a>IntentFilter的匹配规则</h1>\n<p>一个过滤列表中的action，category，data可以有多个，所有的action，category，data分别构成不同的类别。只要有一个Intent能够同时匹配action、category、data类别才能匹配成功。一个Activity可以有多个IntentFilter，只要成功的符合一组IntentFilter就可以启动相应的Activity。 </p>\n<h2><a href=\"#action的匹配规则\" name=\"action的匹配规则\"></a>action的匹配规则</h2>\n<p>action是一个字符串，系统定义了一些，同时也支持自定义此字符串。action**严格区分大小写**。 </p>\n<p>一个过滤规则中可以有多个action，只要有一个action和intent匹配，就可以匹配成功。 </p>\n<p><strong>IntentFilter必须存在，否则不能启动Activity。</strong> </p>\n<h2><a href=\"#category匹配规则\" name=\"category匹配规则\"></a>category匹配规则</h2>\n<p>category也是字符串，系统也有默认的字符串，和action匹配规则不同的是，在intent中可以不用特别指明category属性。 </p>\n<p><strong>IntentFilter中必须要有</strong><code>&lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;</code> 无论intent是否调用addCategory()方法。 </p>\n<p>在Manifest文件中也可以像action一样设置多个category标签，只要有一个匹配就可以。 </p>\n<pre><code> Intent intent = new Intent();\n     intent.setAction(\"com.example.dimple.action.activity2\");\n     intent.addCategory(\"com.example.dimple.category.activity2\");\n    //判断是否有Activity能够匹配intent。防止启动报错！\n     if (intent.resolveActivity(getPackageManager()) != null) {\n         startActivity(intent);\n      }\n</code></pre>\n<h2><a href=\"#data的匹配规则\" name=\"data的匹配规则\"></a>data的匹配规则</h2>\n<p>data的匹配规则和action类似，如果过滤规则中定义了data，那么在Intent中也需要有可以与之匹配的data。但data可以省略不写。 </p>\n<p>语法如下： </p>\n<pre><code> &lt;data android:scheme=\"string\" \n android:host=\"string\" \n android:port=\"number\" \n android:path=\"/string\" \n android:pathPattern=\"string\" \n android:pathPrefix=\"/string\" \n android:mimeType=\"string\"/&gt;\n</code></pre>\n<p>data 由两部分组成，mimeType和URL（mimeType表示媒体类型，比如image/jpg、audio/mp3等，可以表示图，文本等不同格式），URL的格式如下： </p>\n<p><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code><br>- scheme:URL的模式，比如http、file、content，如果URL中没有scheme，那么URL无效。<br>- host：主机名称，比如www.bianxiaofeng.com，如果没有host，则URL无效。<br>- port：端口<br>-path、pathPattern、pathPrefix：表示路径信息 </p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>在通过隐式启动Activity的时候，最好是通过PackageManager的resolveActivity方法或者Intent的resolveActivity方法来判断下是不是有能够负责匹配规则的Activity存在，防止异常出错。 </p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:27:14' WHERE (`blog_id`='15');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='16', `category_id`='52', `title`='Execution failed for task \':app:transformDexArchiveWithExternalLibsDexMergerForDebug\'的解决办法', `summary`='在Android的开源环境下，也就多出来很多优秀的第三方的项目，但是因为很多第三方的项目和目前你正在开发的APP使用的Lib有些是重复的，这样会导致transformClassesWithDexForDebug', `status`='1', `weight`='0', `support`='0', `click`='420', `header_img`='/img/330798-1F41111104993.jpg', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>在Android的开源环境下，也就多出来很多优秀的第三方的项目，但是因为很多第三方的项目和目前你正在开发的APP使用的Lib有些是重复的，这样会导致<b>transformClassesWithDexForDebug</b></p>\n<p><img src=\"http://images.bianxiaofeng.com/615a231d32e95f7c17055c7b906d9c20.png\" style=\"\"><br></p>\n<p>本文介绍年两种方法来处理这个问题。<br></p>\n<h1><a href=\"#解决方案\" name=\"解决方案\"></a>解决方案</h1>\n<h2><a href=\"#添加-multidexenabled-true-到-defaultconfig\" name=\"添加-multidexenabled-true-到-defaultconfig\"></a>添加“multiDexEnabled true”到 defaultConfig</h2>\n<p>在app的build.gradle文件中的 defaultConfig添加： </p>\n<p><code>multiDexEnabled true</code><br>如图所示：</p><p><img src=\"http://images.bianxiaofeng.com/a562375d9b1458bc22e0c43ddfeba579.png\" style=\"\"><br></p>\n<p>这样的设置只能解决一部分的问题，而更加难受的情况是在项目中引入了很多的第三方库，这个时候鬼知道哪个库出了问题，一个一个试可能能够找出来，但是找出来黄花菜都凉了。 </p>\n<p>这个时候请移步解决方法二 </p>\n<h2><a href=\"#根据message信息找到重复的包\" name=\"根据message信息找到重复的包\"></a>根据Message信息找到重复的包</h2>\n<p>在Setting-&gt;Build,Execution,Deployment-&gt;Compiler中的Command-line Opptions中输入**–stacktrace**启用堆栈跟踪</p><p><img src=\"http://images.bianxiaofeng.com/2e03c48ad95cd4925f9ff167419f9c7d.png\" style=\"\"><br></p>\n<p>接着运行APP，就能够在Message上面输出： </p>\n<p><img src=\"http://images.bianxiaofeng.com/962eb9aa80df78c5158c5cf0f2e43cf4.png\" style=\"\"><br></p>\n<p>这样我根据上面消息找到了butterknife重复包。 </p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:35:39' WHERE (`blog_id`='16');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='1', `category_id`='50', `title`='MyEclipse2017 CI7 集成开发环境的破解与使用', `summary`='MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。', `status`='1', `weight`='0', `support`='0', `click`='181', `header_img`='/img/657b07046abc1a8dd3de65ea80f37ded.jpg', `type`='2', `content`='<h1><a href=\"#myeclipse2017-ci7-集成开发环境的破解与使用\" name=\"myeclipse2017-ci7-集成开发环境的破解与使用\"></a>MyEclipse2017 CI7 集成开发环境的破解与使用</h1>\n<blockquote>\n  <p>MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。<br>MyEclipse企业级工作平台（MyEclipseEnterprise Workbench ，简称MyEclipse）是对EclipseIDE的扩展，利用它我们可以在数据库和JavaEE的开发、发布以及应用程序服务器的整合方面极大的提高工作效率。它是功能丰富的JavaEE集成开发环境，包括了完备的编码、调试、测试和发布功能，完整支持HTML，Struts，JSP，CSS，Javascript，Spring，SQL，Hibernate 。<br>MyEclipse 是一个十分优秀的用于开发Java, J2EE的 Eclipse 插件集合，MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持十分不错。MyEclipse可以支持Java Servlet，AJAX，JSP，JSF，Struts，Spring，Hibernate，EJB3，JDBC数据库链接工具等多项功能。可以说MyEclipse是几乎囊括了目前所有主流开源产品的专属eclipse开发工具。——  [百度百科 ]</p>\n</blockquote>\n<p><em>本文主要通过本人自己的经验对网上的一些各类大神的教程进行总结与更新（大神们的教程已经发布很久了，不能适用现在的最新版本）。</em><br>备注：本教程默认读者是配置好了JAVA的相关环境的，请读者自行配置相关环境。</p>\n<h2><a href=\"#下载\" name=\"下载\"></a>下载</h2>\n<h3><a href=\"#下载地址\" name=\"下载地址\"></a>下载地址</h3>\n<p>下载地址建议还是去官方的网站吧，为了安全。嘻嘻</p>\n<pre><code>    附上下载地址：http://www.myeclipsecn.com/download/\n</code></pre>\n<p>注：下载需要微信扫码获取密码。<br><img src=\"http://img.blog.csdn.net/20170907122010684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"注意我使用的版本为MyEclipse 2017 CI 7（2017-7-12更新），以后更新的版本有可能破解方法不能适用\"><br> 注意我使用的版本为MyEclipse 2017 CI 7（2017-7-12更新）</p>\n<p>下载默认安装即可。</p>\n<h3><a href=\"#注意事项\" name=\"注意事项\"></a>注意事项</h3>\n<p><strong><em>安装完毕之后，一定要记住，不要选择那个默认的打开MyEclipse ！！！</em></strong></p><p><strong><em><br></em></strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170907162256989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2><a href=\"#破解\" name=\"破解\"></a>破解</h2>\n<p>然后使用我们的破解工具：<br> 破解工具下载地址：http://download.csdn.net/download/qq_32454537/9968200</p>\n<h3><a href=\"#1-解压文件后打开文件夹-\" name=\"1-解压文件后打开文件夹-\"></a>1、解压文件后打开文件夹：</h3>\n<p><img src=\"http://img.blog.csdn.net/20170907122456966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n<h3><a href=\"#2-复制这里面的所有内容-\" name=\"2-复制这里面的所有内容-\"></a>2、复制这里面的所有内容：</h3>\n<p><img src=\"http://img.blog.csdn.net/20170907122549774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3><a href=\"#3-到myeclipse的安装目录下-\" name=\"3-到myeclipse的安装目录下-\"></a>3、到MyEclipse的安装目录下：</h3>\n<p><img src=\"http://img.blog.csdn.net/20170907122656782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3><a href=\"#4-复制到这个plugins文件夹内-覆盖就可-\" name=\"4-复制到这个plugins文件夹内-覆盖就可-\"></a>4、复制到这个plugins文件夹内，覆盖就可。</h3>\n<p>ps：一共是64个文件。</p>\n<h3><a href=\"#5-打开myeclipse2017-keygen这个文件夹\" name=\"5-打开myeclipse2017-keygen这个文件夹\"></a>5、打开myeclipse2017_keygen这个文件夹</h3>\n<p><img src=\"http://img.blog.csdn.net/20170907122900501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3><a href=\"#6-打开之后双击打开红框部分\" name=\"6-打开之后双击打开红框部分\"></a>6、打开之后双击打开红框部分</h3>\n<p><img src=\"http://img.blog.csdn.net/20170907122934081?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3><a href=\"#7-打开后如图\" name=\"7-打开后如图\"></a>7、打开后如图</h3>\n<p>填写UserCode为任意英文或者数字，这里填写为admin、<br>下面一个下拉选择框选择BLUE<br>按SystemId按钮，可能需要按两下，知道SystemId输入框出现一连串的“莫名其妙”的符号。<br>这个时候再按Active按钮，此时最下面的TextView就会出现这么一坨东西，代表基本成功<br><img src=\"http://img.blog.csdn.net/20170907162902448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>这个时候，还需要点击Tools，选择tools里的save propertity<br><img src=\"http://img.blog.csdn.net/20170907163006825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>PS：附上操作顺序图<br><img src=\"http://img.blog.csdn.net/20170907123217745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后打开MyEclipse敬请享用吧。</p>\n<p>如果有问题欢迎回复。我在线都会答。</p>\n<h2><a href=\"#其他事项\" name=\"其他事项\"></a>其他事项</h2>\n<h3><a href=\"#2017年9月8日更新-\" name=\"2017年9月8日更新-\"></a>2017年9月8日更新：</h3>\n<p>如果出现了破解失败，即进去显示还有5天就到期。<br>请按照以下步骤执行：<br>1、首先卸载MyEclipse ，卸载完毕后请删除MyEclipse中的所有的文件。<br>2、按住Windows键+R，输入regedit，进去注册表编辑页面，按住Ctrl+F，出来搜索框，请输入：MyEclipse，然后回车，进行搜索，搜索出来了按del键进行删除。然后再按住F3继续搜索，直到搜索完毕。<br>3、重新按照如上步骤，重新破解安装。</p>\n<h3><a href=\"#2017年12月30日更新-\" name=\"2017年12月30日更新-\"></a>2017年12月30日更新：</h3>\n<p>也没更新啥，就换了下排版嘻嘻嘻！</p>\n<p>本文链接：http://blog.csdn.net/qq_32454537/article/details/77880294</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:36:19' WHERE (`blog_id`='1');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='9', `category_id`='51', `title`='大学期间的视频文档', `summary`='考完试恍恍惚惚，简直不敢相信大三已经又过去了一半了，时间是真的快。经历了前两天去西岭雪山玩的时候手机丢了的不愉快，决定好好整理了下大学做过的一些东西，做一个备份。', `status`='1', `weight`='0', `support`='0', `click`='489', `header_img`='/img/657b07046abc1a8dd3de65ea80f37ded.jpg', `type`='2', `content`='<p><span style=\"color: inherit; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 36px;\">前言</span><br></p>\n<p>考完试恍恍惚惚，简直不敢相信大三已经又过去了一半了，时间是真的快。经历了前两天去西岭雪山玩的时候手机丢了的不愉快，决定好好整理了下大学做过的一些东西，做一个备份。 </p>\n<h2><a href=\"#视频篇\" name=\"视频篇\"></a>视频篇</h2>\n<h3><a href=\"#成都大学信息科学与工程学院-2016年迎新晚会暖场视频\" name=\"成都大学信息科学与工程学院-2016年迎新晚会暖场视频\"></a>成都大学信息科学与工程学院 2016年迎新晚会暖场视频</h3>\n<p>这是我担任学生会科文部部长的时候带领小干事们做的一些东西。权当留个纪念吧，我相信这套视频，对于16级的小同学们来说有着特别的意义。</p><p><a href=\"http://www.iqiyi.com/w_19rwhy0npt.html\" target=\"_blank\">http://www.iqiyi.com/w_19rwhy0npt.html</a><br></p><p> </p>\n<h3>成都大学信息科学与工程学院学生会招新视频</h3><p><a href=\"http://v.youku.com/v_show/id_XMTY5NjQ5NTM4NA==.html\" target=\"_blank\">http://v.youku.com/v_show/id_XMTY5NjQ5NTM4NA==.html</a><br></p>\n<h3>《基于无线传感器网的物联网智慧农业系统》展示视频</h3>\n<p>这一套系统呢是由我担任硬件开发兼项目负责人，我的学长余悦担任软件开发，当时大一小朋友蒋蕊担任项目答辩。最好的成绩呢是获得了全国物联网大赛一等奖。</p><p><a href=\"http://www.iqiyi.com/w_19rwhxeq81.html\" target=\"_blank\">http://www.iqiyi.com/w_19rwhxeq81.html</a><br></p>\n<h3><a href=\"#来影-一款基于ar与3d的旅游软件项目展示\" name=\"来影-一款基于ar与3d的旅游软件项目展示\"></a>来影——一款基于AR与3D的旅游软件项目展示</h3>\n<p>这个是我担任Android开发以及项目负责人做的视频，获得了中星杯计算机作品大赛二等奖，计算机设计大赛，互联网+大赛的一些奖。</p><p><a href=\"http://www.iqiyi.com/w_19rwhwxmw1.html\" target=\"_blank\">http://www.iqiyi.com/w_19rwhwxmw1.html</a><br></p>\n<p>还有很多给老师做的一些视频就不放上来了。 </p>\n<h2><a href=\"#文档篇\" name=\"文档篇\"></a>文档篇</h2>\n<h3><a href=\"#office使用手册\" name=\"office使用手册\"></a>OFFICE使用手册</h3>\n<h4><a href=\"#ppt使用手册\" name=\"ppt使用手册\"></a>PPT使用手册</h4>\n<p><a href=\"https://pan.baidu.com/s/1c3T7Nf6\">PPT 使用手册</a> </p>\n<p><br></p>\n<h4><a href=\"#word使用手册\" name=\"word使用手册\"></a>Word使用手册</h4>\n<p><a href=\"https://pan.baidu.com/s/1sneCBmt\">Word 使用手册</a> </p>\n<p><br></p>\n<h4><a href=\"#excel使用手册\" name=\"excel使用手册\"></a>Excel使用手册</h4>\n<p><a href=\"https://pan.baidu.com/s/1pNaCVvt\">Excel 使用手册</a> </p>\n<p><br></p>\n<p>洋洋洒洒的几十页，在成都大学信工学院的学生群里面传播，也希望能够实实在在的帮助到他们。 如果有需要的话可以直接下载了。 </p>\n<h3><a href=\"#it来袭策划书\" name=\"it来袭策划书\"></a>IT来袭策划书</h3>\n<p>当然了，作为部长的我是经历了成都大学第八届、第九届、第十届的IT来袭的，覆盖全校的校级大型活动，作为负责人还是很辛苦的，也很感谢我身边的人，不管是我的老部长还有小干事们，还有帮助我们活动的各位老大们。 </p>\n<p><br></p>\n<p>链接：<a href=\"https://pan.baidu.com/s/1mkd0ScS\" target=\"_blank\">https://pan.baidu.com/s/1mkd0ScS </a>密码：0hdb </p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>还是有一些感触的，很多视频做的时候就完全不知道怎么做，逼出来的，现在看看还是很不错的。权当留个纪念吧，自己的电脑是一日不如一日，不知道什么时候就彻底歇逼了。对于IT来袭活动，印象应该是最深的了吧。我全程陪伴，全程关注。分配了任务，我会一点一点的督促落实，也得到了各位老师同学的肯定，参与人数达历史新高，近2000人。<br>科文部确实是一个很好的部门，带给人的影响积极而无声。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:28:51' WHERE (`blog_id`='9');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='24', `category_id`='48', `title`='Java中的内存回收与内存泄漏的防治', `summary`='对于JVM（Java虚拟机）的GC（垃圾回收机制）来说，是否回收一个对象的标准是：是否还有引用变量指向该对象。只有有引用变量指向该对象，那么JVM就不会考虑去回收它。而在学习Java的时候，一般都是会说：Java有一套完整的垃圾回收机制，程序员可以不需要考虑内存。但是在实际应用中，还是会出现“内存泄漏”的情况。', `status`='1', `weight`='0', `support`='0', `click`='755', `header_img`='/img/wm1.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>对于JVM（Java虚拟机）的GC（垃圾回收机制）来说，是否回收一个对象的标准是：是否还有引用变量指向该对象。只有有引用变量指向该对象，那么JVM就不会考虑去回收它。</p>\n<p>而在学习Java的时候，一般都是会说：Java有一套完整的垃圾回收机制，程序员可以不需要考虑内存。但是在实际应用中，还是会出现“内存泄漏”的情况。<br></p>\n<h1><a href=\"#对象在内存中的状态\" name=\"对象在内存中的状态\"></a>对象在内存中的状态</h1>\n<p>基本上可以将JVM中的对象引用理解为离散中学到的有向图。</p>\n<p>将对象当做有向图的**顶点**，将引用关系当做有向图的有向边，有向边总是从引用端指向被引用的变量。在JVM中，Java的各种对象都是由各个线程创建的，所以可以将Java的线程对象作为有向图的起点。</p>\n<p>如果按照上述的方式，对于某一个对象来说，始终有大于等于一条路径能够从起点指到它，那么它就不会被GC。当然，如果找不到一条路径能够指向它，那么它就可能会被回收（注意这里说的是可能，因为GC的回收机制是由一套相对复杂的算法来决定的，所有的对象并不是失去引用马上就会被回收）。</p>\n<p>那么，是不是所有的对象，只要有引用指向它，它就不会被回收呢？但是是否定的，原因请继续往下看。</p>\n<p>而一般来说，对于Java中的对象引用有4种方式：强引用、弱引用、软引用和虚引用。</p>\n<p>关于这几种引用的概念，简单的说明如如下：</p>\n<h2><a href=\"#强引用\" name=\"强引用\"></a>强引用</h2>\n<p>对于强引用来说，可能我们平时在写代码的时候，都是用的强引用，被强引用的Java对象时不会被垃圾回收机制给回收的。即使系统资源非常紧张，即使有些变量以后都不会用到，JVM也不会强制回收被强类型引用的变量，如果系统内存实在不够，程序会直接抛出OutOfMemory异常。</p>\n<p>而我们在平常的开发中，使用的最多的也是这种，比如<br><code>1Person person =new Person();</code></p>\n<h2><a href=\"#软引用\" name=\"软引用\"></a>软引用</h2>\n<p>软引用需要通过SoftReference来实现，当一个对象只具有SoftReference时，它可能会被垃圾回收机制给回收，但是对于SoftReference的对象来说，当系统资源足够时，它是不会被系统回收，程序可以使用该对象，但是当系统资源不够的时候，GC会回收它。</p>\n<p>使用的方法一般如下：</p>\n<p><code>SoftReference&lt;Person&gt;[] persons=new SoftReference[1000000]</code></p>\n<h2><a href=\"#弱引用\" name=\"弱引用\"></a>弱引用</h2>\n<p>弱引用和软引用有些相似，区别在于 弱引用的生命周期更短，弱引用需要通过WeakReference来实现，对于只有弱引用对象，当GC运行时，无论系统资源是否足够，该对象都会被回收。（这里还是需要提醒一下，GC的运行不是实时的，不是说当该对象不再被引用变量引用的时候，GC会立即运行来回收它）</p>\n<p>当然了，这样的设计是有一定的道理的，这样是为了更加好的解决系统资源。由于GC的不定时，所以可能会遇到空指针异常，所以在进行业务逻辑处理的时候，建议在开始的时候，判断下该对象是不是为空。</p>\n<h2><a href=\"#虚引用\" name=\"虚引用\"></a>虚引用</h2>\n<p>虚引用通过PhantomReference类实现，它完全类似于没有引用。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独被使用，虚引用必须要和引用队列（ReferenceQueue）一起使用。</p>\n<h2><a href=\"#对象在堆中的几种状态\" name=\"对象在堆中的几种状态\"></a>对象在堆中的几种状态</h2>\n<p>一个对象在堆中运行时，根据它在有向图中的状态可以分为3种：</p>\n<h3><a href=\"#可达状态\" name=\"可达状态\"></a>可达状态</h3>\n<p>当一个对象被创建后，有一个以上的引用变量引用它，在有向图中可以从起始顶点导航到该对象，那么就处于可达状态。</p>\n<h3><a href=\"#可恢复状态\" name=\"可恢复状态\"></a>可恢复状态</h3>\n<p>如果程序中某个对象不在有任何引用变量引用它，它将先进入可恢复状态，此时从有向图的顶点不能导航到该对象，在这个状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，会调用可恢复状态的对象的finalize方法进行资源清理，如果在系统调用finalize方法重新让一个以上的引用引用该对象，那么这个对象就可以变成可达状态。否则，该对象将进入到不可达状态。</p>\n<h3><a href=\"#不可达状态\" name=\"不可达状态\"></a>不可达状态</h3>\n<p>当对象的所有关联都被切断，且系统调用所有对象finalize依然没有使该对象变为可达状态，那这个对象将永久性的失去引用，当一个对象处于不可达状态时，系统才会真正的回收该对象所占用的资源。</p>\n<h1><a href=\"#java的内存泄漏\" name=\"java的内存泄漏\"></a>Java的内存泄漏</h1>\n<blockquote>\n  <p>定义：程序运行过程中会不断的分配内存空间，那些不再使用的内存空间应该立即回收它，从而保证系统再次使用这些内存，如果存在无用的内存被回收回来，那么就叫内存泄漏。</p>\n</blockquote>\n<h2><a href=\"#内存管理的技巧\" name=\"内存管理的技巧\"></a>内存管理的技巧</h2>\n<p>1、尽量使用直接量，比如String s=:“hello”;而不是String s=new String (“hello”)，这两种方法都会在再字符串缓冲池里面有缓存，区别是使用new的方式底层会创建一个char[]数组。</p>\n<p>2、使用StringBuilder和StringBuffer进行字符串连接。如果使用String对象进行字符串连接，会生成大量的临时字符串会导致性能下降。</p>\n<p>3、尽早释放无用对象的引用。</p>\n<p>4、尽量少使用静态变量，因为静态变量的生命周期和类同步，只要class没有被卸载，那么就会一直常驻内存。</p>\n<p>5、避免在经常调用的方法，循环中创建Java对象。这样会导致系统不断的为变量分配释放空间。</p>\n<p>6、缓存经常使用的对象：如果有些对象需要被经常使用，那么可以考虑将这些对象用缓冲池保存起来，典型的缓存就是数据连接池。 </p>\n<p>PS：缓存的设计本身就是一种牺牲系统空间来换取运行时间的方式。如何控制缓存容器占用的内存空间不至于太大，同时又能保存大部分需要使用到的对象，这是缓存的设计的关键。</p>\n<p>7、尽量不要使用finalize方法</p>\n<p>8、考虑使用softReference，但是要注意软引用的不确定性。</p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>引用对象有4个级别，其由高到低一次为：强引用、软引用、弱引用和虚引用。在需要严格考虑系统资源的情况下，还是需要考虑到这个系统的消耗的，这个时候就不能一味的使用强类型引用了。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:33:18' WHERE (`blog_id`='24');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='25', `category_id`='48', `title`='Java异常', `summary`='异常：程序在运行的过程中，如果程序执行出错，阻止了程序的正常运行，那么就会产生异常。而在Java中有一套解决方案，这就是异常处理机制。Java中的异常机制是针对正常运行程序的一个必要补充，一般来说没有加入异常机制，程序也能正常运行，但是，由于入参、程序逻辑的严谨度，总会有期望之外的结果生成，因此加入异常机制的补充，就是为了更好的处理意料之外的结果。', `status`='1', `weight`='0', `support`='0', `click`='647', `header_img`='/img/wm1.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>在面试的过程中一般会问道关于Java的异常处理相关的内容，异常处理是一般容易被忽略的，但是确是很考验一个程序员功底的方面。本文会介绍关于异常，以及关于异常的面试会问到的一些问题。</p>\n<h1><a href=\"#异常的分类\" name=\"异常的分类\"></a>异常的分类</h1>\n<blockquote>\n  <p>异常：程序在运行的过程中，如果程序执行出错，阻止了程序的正常运行，那么就会产生异常。而在Java中有一套解决方案，这就是异常处理机制。Java中的异常机制是针对正常运行程序的一个必要补充，一般来说没有加入异常机制，程序也能正常运行，但是，由于入参、程序逻辑的严谨度，总会有期望之外的结果生成，因此加入异常机制的补充，就是为了更好的处理意料之外的结果。<br><br>首先说第一点：</p>\n</blockquote>\n<p><strong>所有的异常类的父类是throwable</strong>，这个出现在我的笔试题上面，是一道判断题，但是当时没有回答正确。</p><p><img src=\"http://images.bianxiaofeng.com/b2bd059993649deadffa577b09489d11.png\" style=\"\"><br></p>\n<p><img src=\"http://images.bianxiaofeng.com/968c09f90098bdc6239e5c33ce1dadfe.png\" style=\"\"><br></p>\n<p>通过以上两张图就能看到Exception和Error的直接父类是Throwable，而Throwable是实现了Serializable接口，Object的子类。</p>\n<p>以上就是它们三者的关系。</p>\n<p>首先具体说下Exception。</p>\n<h1><a href=\"#exception的分类\" name=\"exception的分类\"></a>Exception的分类</h1>\n<p>Java中的异常分为两大类：</p>\n<ul>\n  <li>Checked Exception （受检异常，也叫非运行时异常）</li>\n  <li>Unchecked Exception （也叫RuntimeException，运行时异常）</li>\n</ul>\n<p>所有的运行时异常都是直接或者间接的继承自RuntimeException类的，比如下面图中的空指针异常。</p><p><img src=\"http://images.bianxiaofeng.com/be9cdb13ac0d67414bb69ca6f4ab1e23.png\" style=\"\"><br></p>\n<p>凡是没有继承RuntimeException而是直接继承的Exception的，叫做受检异常。<br>比如IO异常。</p><p><img src=\"http://images.bianxiaofeng.com/4a3e9bf06aa4a468ccbbf1faeddaba82.png\" style=\"\"><br></p>\n<p>接下来具体的说明这些异常：</p>\n<p><img src=\"http://images.bianxiaofeng.com/175665caadc19bda8d43702d579972d9.png\" style=\"\"><br></p>\n<p>其他要说的：</p>\n<h2><a href=\"#checked-exception\" name=\"checked-exception\"></a>Checked Exception</h2>\n<p>对于Checked Exception ，Java要求程序员对这样的操作进行预处理。即用try、catch、finally或者throws，要么在方法中使用TCF三连，或者直接抛出交给他的上一级进行处理。</p>\n<p>对于这样的情况是必须要进行处理的，如果不进行处理，程序都不能被编译。</p>\n<p>比如常见的加载驱动：<br><code>Class.forName(\"xxx\")</code>就必须要进行处理，否则会抛出ClassNotFoundException受检异常，不处理是不能通过编译的。</p>\n<h2><a href=\"#unchecked-exception\" name=\"unchecked-exception\"></a>Unchecked Exception</h2>\n<p>对于Unchecked Exception来说，一般是不需要进行处理的，程序能正常的通过编译。但是为了程序的严谨性，一般还是会在可能发生异常的地方进行TCF三连处理。这类异常常见的如下：<br>* ArithmeticException 算术异常<br>* NullPointerException 空指针异常<br>* ClassCastException 类转换异常<br>* ArrayIndexOutOfBoundsException 数组索引越界异常</p>\n<p>OK，再说下异常的捕获，关于异常，**一般是先捕获小的异常（子类），再捕获大的异常（父类）**。一般是不建议直接用Exception来全给捕获了。</p>\n<p>最后加一个面试题：</p>\n<pre><code> public void testException1() {\n        try {\n            System.out.println(\"In try first\");\n            int i = 3 / 0;\n            System.out.println(\"In try\");\n            return;\n        } catch (ArithmeticException a) {\n            System.out.println(\"In catch\");\n        }finally {\n            System.out.println(\"In finally\");\n        }\n         System.out.println(\"In end\");\n    }\n    public void testException2() {\n        try {\n            int i = 3 / 0;\n            System.out.println(\"In try\");\n            return;\n        } catch (ArithmeticException a) {\n            System.out.println(\"In catch\");\n        }finally {\n            System.out.println(\"In finally\");\n            return;\n        }\n         System.out.println(\"In end\");        \n    }\n</code></pre>\n<p>关于以上的代码，可以自己打断点看一下运行过程：</p>\n<p>结论如下：</p>\n<p>1、在TCF语句中，try部分的代码如果产生了异常，会被catch到然后转入catch语句块中进行处理，最后调用finally语句块（如果有的话）进行最后的资源清理等等工作。</p>\n<p>2、但是如果在finally语句块中有return语句，那么是不会再执行下面的语句的。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:42:47' WHERE (`blog_id`='25');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='27', `category_id`='48', `title`='ObjectMapper类', `summary`='ObjectMapper类是Jackson库的主要类。它提供一些功能将转换成Java对象匹配JSON结构，反之亦然。它使用JsonParser和JsonGenerator的实例实现JSON实际的读/写。', `status`='1', `weight`='0', `support`='0', `click`='293', `header_img`='/img/wm1.png', `type`='2', `content`='<p><span style=\"color: inherit; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 36px;\">前言</span><br></p>\n<p>ObjectMapper类是Jackson库的主要类。它提供一些功能将转换成Java对象匹配JSON结构，反之亦然。它使用JsonParser和JsonGenerator的实例实现JSON实际的读/写。<br></p>\n<h1><a href=\"#使用\" name=\"使用\"></a>使用</h1>\n<p>使用Jackson，首先需要相关的jar包。对于使用maven的，需要添加以下依赖：</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.5&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.5&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.5&lt;/version&gt;\n&lt;/dependency&gt;\n\n\n</code></pre>\n<p>同时，也可以直接下载Jar包。</p>\n<p><a href=\"https://download.csdn.net/download/qq_32454537/10475066\">点我直达</a></p>\n<p>当然了，也可以通过maven的仓库，然后选择jar包下载。</p>\n<p><a href=\"http://mvnrepository.com/\">点我直达</a></p>\n<h1><a href=\"#实例演示\" name=\"实例演示\"></a>实例演示</h1>\n<h2><a href=\"#java对象转换为json对象\" name=\"java对象转换为json对象\"></a>Java对象转换为JSON对象</h2>\n<pre><code><br>ObjectMapper objectMapper = new ObjectMapper();  \n          \n        //序列化的时候序列对象的所有属性  \n        objectMapper.setSerializationInclusion(Include.ALWAYS);  \n          \n        //反序列化的时候如果多了其他属性,不抛出异常  \n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);  \n          \n        //如果是空对象的时候,不抛异常  \n        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);  \n          \n        //取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式  \n        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  \n        objectMapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"))  \n</code></pre>\n<p>Person 类：</p>\n<pre><code><br>public class Person {\n    private int id;\n    private String name;\n    private String password;\n\n    public Person() {\n        super();\n    }\n\n    public Person(int id, String name, String password) {\n        this.id = id;\n        this.name = name;\n        this.password = password;\n    }\n    /*省略get和set方法*/\n}\n</code></pre>\n<p>测试demo：</p>\n<pre><code>package com.dimple.ObjectMapperDemo;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class ObjectMapperTest {\n\n    public static void main(String[] args) throws JsonProcessingException {\n\n        ObjectMapper objectMapper = new ObjectMapper();\n        Person person = new Person(1, \"tom\", \"123\");\n        String jsonString = objectMapper.writeValueAsString(person);\n        System.out.println(\"JsonString: \" + jsonString);\n\n    }\n\n}\n\n</code></pre>\n<p>运行截图如下：</p><p><img src=\"http://images.bianxiaofeng.com/cbdecbe49de0ba8d0e164a6a81431010.png\" style=\"\"><br></p>\n<p>可以看到，使用Jackson类就可以将Java对象转换为Json对象。</p>\n<p>PS：还需要注意，如果ObjectMapper的configure设置FAIL_ON_EMPTY_BEANS为false，那么对应的实体类的属性没有get方法也不会抛出异常，但是这个属性默认的是true，即必须要有get方法，这个需要注意。</p>\n<p>错误如图：</p>\n<blockquote>\n  <p>com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class com.dimple.ObjectMapperDemo.Person and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)</p>\n</blockquote>\n<p><img src=\"http://images.bianxiaofeng.com/5bd444e20c71347a44ba45a1fbca2bb9.png\" style=\"\"><br></p>\n<h2><a href=\"#json对象转为java对象\" name=\"json对象转为java对象\"></a>JSON对象转为Java对象</h2>\n<pre><code>public class ObjectMapperTest {\n\n    public static void main(String[] args) throws IOException {\n\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);\n        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);\n        Person person = new Person(1, \"tom\", \"123\");\n        String jsonString = objectMapper.writeValueAsString(person);\n        System.out.println(\"JsonString: \" + jsonString);\n\n        Person person1 = objectMapper.readValue(jsonString, Person.class);\n        System.out.println(person1.toString());\n\n    }\n\n}\n\n</code></pre>\n<p>结果如图：</p>\n<p><img src=\"http://images.bianxiaofeng.com/5716bf2d792ce5402990feea3a407f45.png\" style=\"\"><br></p>\n<h2><a href=\"#java数组对象和json数组对象转换\" name=\"java数组对象和json数组对象转换\"></a>Java数组对象和JSON数组对象转换</h2>\n<pre><code>public class ObjectMapperTest {\n\n    public static void main(String[] args) throws IOException {\n\n        ObjectMapper objectMapper = new ObjectMapper();\n        //Java数组转换为JSON数组\n        Person person = new Person(1, \"tom\", \"123\");\n        Person person1 = new Person(2, \"jack\", \"123445\");\n        List&lt;Person&gt; personList = new ArrayList&lt;&gt;();\n        personList.add(person);\n        personList.add(person1);\n        String jsonString = objectMapper.writeValueAsString(personList);\n        System.out.println(\"JsonString List: \" + jsonString);\n        //Json数组转换为Java数组\n        //JavaType\n        JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, Person.class);\n        List&lt;Person&gt; list = objectMapper.readValue(jsonString,javaType);\n        //打印出list中的值\n        for (Person person2 : list) {\n            System.out.println(person2.toString());\n        }\n    }\n\n}\n</code></pre>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:43:16' WHERE (`blog_id`='27');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='31', `category_id`='48', `title`='线程相关总结', `summary`='五种状态：New 新建状态：线程被创建后就进入到了新建状态，Thread thread=new Thread();Runnable 就绪状态：线程被创建后，其他线程调用该线程的start方法来启动该线程。处于就绪状态的线程，随时可能被CPU调度。Running 运行状态：线程获取CPU执行。线程只能从就绪状态转为运行状态。Blocked 阻塞状态： 线程因为某种原因放弃CPU的使用。只有直到线程进入到就绪状态，才有机会转入运行状态。', `status`='1', `weight`='0', `support`='0', `click`='299', `header_img`='/img/wm1.png', `type`='2', `content`='<p><span style=\"color: inherit; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 30px;\">1、Object类的wait()、notify()；Thread类中接口、synchronized关键字。</span><br></p>\n<p>五种状态：</p>\n<p><strong>New 新建状态</strong>：线程被创建后就进入到了新建状态，Thread thread=new Thread();</p>\n<p><strong>Runnable 就绪状态</strong>：线程被创建后，其他线程调用该线程的start方法来启动该线程。处于就绪状态的线程，随时可能被CPU调度。</p>\n<p><strong>Running 运行状态</strong>：线程获取CPU执行。线程只能从就绪状态转为运行状态。</p>\n<p><strong>Blocked 阻塞状态：</strong> 线程因为某种原因放弃CPU的使用。只有直到线程进入到就绪状态，才有机会转入运行状态。</p>\n<p><strong>等待阻塞</strong>： 调用线程的wait()方法，让线程等待某工作完成。</p>\n<p><strong>同步阻塞</strong>： 线程在获取synchronized同步锁失败（同步锁被其他线程占用），会进入到同步阻塞状态。</p>\n<p><strong>其他阻塞</strong>： 通过调用线程的sleep()或join或发出IO请求。</p>\n<p><strong>Dead 死亡状态</strong>：线程执行完毕或者因为一场退出run()方法。<br></p>\n<h2><a href=\"#2-实现多线程的两种方式\" name=\"2-实现多线程的两种方式\"></a>2、实现多线程的两种方式</h2>\n<ul>\n  <li>\n  <p>实现runnable接口</p></li>\n  <li>\n  <p>继承Thread类，该类实现了runnable接口</p></li>\n</ul>\n<p>Thread 和 Runnable 的相同点：都是“多线程的实现方式”。</p>\n<p>Thread 和 Runnable 的不同点：</p>\n<p>Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。</p>\n<p>此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。</p>\n<p>通常，建议通过“Runnable”实现多线程！</p>\n<h2><a href=\"#3-start-和run-的区别\" name=\"3-start-和run-的区别\"></a>3、start()和run()的区别</h2>\n<p>start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。<br>run() : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>\n<p>target是一个runnale对象，run()就是直接调用Thread的Runnable的run()方法。</p>\n<h2><a href=\"#4-synchronized关键字\" name=\"4-synchronized关键字\"></a>4、Synchronized关键字</h2>\n<p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。</p>\n<p>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。</p>\n<p>不同线程对同步锁的访问是互斥的。</p>\n<p>原则</p>\n<p>第一条：当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>\n<p>第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</p>\n<p>第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>\n<p>##5、线程的等待与唤醒<br>在Object类中定义了wait()、notify()和notifyAll()等接口；</p>\n<p>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁；<br>而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程；</p>\n<p>Object类中关于等待/唤醒的API详细信息如下：</p>\n<p>notify() – 唤醒在此对象监视器上等待的单个线程。</p>\n<p>notifyAll() – 唤醒在此对象监视器上等待的所有线程。</p>\n<p>wait() – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</p>\n<p>wait(long timeout) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n<p>wait(long timeout, int nanos) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n<h2><a href=\"#6-线程让步\" name=\"6-线程让步\"></a>6、线程让步</h2>\n<p>方法：yieId()<br>作用：让步，让当前的线程由运行状态进入到就绪状态，从而让其他具有相同优先级的线程获得执行权。但是不能保证其他线程就一定能获得执行权，也有可能是当前线程又进入到运行状态继续运行。</p>\n<p>yieId和wait区别：</p>\n<p>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。</p>\n<p>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>\n<h2><a href=\"#7-线程休眠\" name=\"7-线程休眠\"></a>7、线程休眠</h2>\n<p>sleep在一下Thread类中，作用是让当前的线程休眠，即当前线程会从运行状态进入到阻塞状态。当时间到了的时候，会从阻塞状态变为就绪状态，等待CPU调度。</p>\n<p>sleep和wait的比较：</p>\n<p>wait的作用是让当前线程由运行状态进入到阻塞状态，同时释放掉同步锁。而sleep的作用也是让当前线程进入到阻塞状态，但是不会释放掉同步锁。</p>\n<h2><a href=\"#8-join\" name=\"8-join\"></a>8、join</h2>\n<p>join()定义在Thread类中。<br>作用为：让“主线程”等待“子线程”结束之后才运行。</p>\n<h2><a href=\"#9-interrupt-和线程终止方式\" name=\"9-interrupt-和线程终止方式\"></a>9、interrupt()和线程终止方式</h2>\n<p>interrupt()的作用是中断本线程。本线程中断自己是被允许的，其他线程调用本线程的interrupt方法的时候，会通过checkAccess()检查权限，这有可能抛出SecurityException异常。</p>\n<p>通常我们会通过中断方式终止处于“阻塞状态”的线程。</p>\n<p>当线程由于调用了sleep()、wait()、join()等方法而进入到阻塞状态；此时若调用线程的interrupt()方法将线程的中断标记设为了true，由于处于阻塞状态，中断标记会被清除，同时产生一个interruptException异常。将interruptException放在适当的位置就能终止线程；</p>\n<p>interrupt()并不会终止“运行状态”的线程，它会将线程的中断标记设为true。（通过isInterrupted()方法判断线程是不是处于中断状态）。</p>\n<p>终止线程的通用写法：</p>\n<pre><code>@Override\npublic void run() {\n    try {\n        // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n        while (!isInterrupted()) {\n            // 执行任务...\n        }\n    } catch (InterruptedException ie) {  \n        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n    }\n}\n</code></pre>\n<p>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>\n<h2><a href=\"#10-线程优先级和守护线程\" name=\"10-线程优先级和守护线程\"></a>10、线程优先级和守护线程</h2>\n<p>Java 中的线程的优先级是1—10，默认优先级是5。</p>\n<p>Java中有两种线程，用户线程和守护线程。可以通过isDaemon()（守护线程）方法来区别。用户线程一般执行用户级线程，而守护线程也就是后台线程。</p>\n<p>PS：Java虚拟机在“用户线程”都结束后退出。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:43:40' WHERE (`blog_id`='31');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='32', `category_id`='48', `title`='Java创建对象的几种方式', `summary`='Java是一门面向对象的程序设计语言，在日常开发中可能最常见的就是使用new关键字进行对象的创建了。其实创建对象的方式有很多中，在此，准备将实例化对象的方式进行总结，归纳整理。在此之前，先简单的说明一般会有以下五种方式实例化对象：①、使用new关键字；②、使用Class类的newInstance方法；③、使用Constructor类的newInstance方法；④、使用Object类的clone方法；⑤、使用反序列化的方式；', `status`='1', `weight`='0', `support`='1', `click`='126', `header_img`='/img/wm1.png', `type`='2', `content`='<p><span style=\"color: inherit; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 36px;\">前言</span><br></p>\n<p>Java是一门面向对象的程序设计语言，在日常开发中可能最常见的就是使用new关键字进行对象的创建了。其实创建对象的方式有很多中，在此，准备将实例化对象的方式进行总结，归纳整理。</p>\n<p>在此之前，先简单的说明一般会有以下五种方式实例化对象：</p>\n<p>①、使用new关键字；</p>\n<p>②、使用Class类的newInstance方法；</p>\n<p>③、使用Constructor类的newInstance方法；</p>\n<p>④、使用Object类的clone方法；</p>\n<p>⑤、使用反序列化的方式；<br></p>\n<h1><a href=\"#实例化对象的几种方式\" name=\"实例化对象的几种方式\"></a>实例化对象的几种方式</h1>\n<h2><a href=\"#new关键字实例化对象\" name=\"new关键字实例化对象\"></a>new关键字实例化对象</h2>\n<p>最常见，也是最简单的实例化对象的方式，通过这种方式，可以调用任意一个构造函数。</p>\n<p>如：</p>\n<pre><code>    Student student = new Student();\n    Student student = new Student(\"小明\");\n</code></pre>\n<h2><a href=\"#使用class类的newinstance方法\" name=\"使用class类的newinstance方法\"></a>使用Class类的newInstance方法</h2>\n<p>使用Class类的newInstance方法，此方法会默认调用对象的无参构造器，所以如果有重写构造器的话需要显式写出无参构造器，否则会报“InstantiationException”异常。</p>\n<pre><code>	Student classStudent = (Student) Class.forName(\"com.dimple.NewObject.Student\").newInstance();//需要无参构造器，使用Class的\n	classStudent.sayHello();\n</code></pre>\n<p>当然了，也可以这样写：</p>\n<pre><code>    Student classStudent = Student.class.newInstance();\n	classStudent.sayHello();\n</code></pre>\n<p><em>使用Student.class代替常常的全限定名。</em></p>\n<h2><a href=\"#使用constructor的newinstance方法\" name=\"使用constructor的newinstance方法\"></a>使用Constructor的newInstance方法</h2>\n<p>java.lang.reflect.Constructor类中也有一个newInstance方法可以反射创建对象。<br>查看源码可以看到newInstance的方法如下：</p><p><img src=\"http://images.bianxiaofeng.com/57f897e9d2d1c78422651876a1ac19cc.png\" style=\"\"><br></p>\n<p>可以看到该方法是有不定参数的，而这个参数最终是调用ConstructorAccessor的newInstance方法的参数，所以Contstructor的newInstance方法是可以调用有参构造器的。</p>\n<p>反观Class类的newInstance方法是没有任何参数可以传递的，这也就意味它不能调用有参构造，只能是使用默认的构造器进行实例化。</p>\n<pre><code>    Constructor&lt;Student&gt; constructor = Student.class.getConstructor(String.class);\n	Student constructorStudent = constructor.newInstance(\"小明\");\n</code></pre>\n<p><em>Spring、Hibernate、Struts等开源框架，也是采用的这种方式进行实例化对象，并采用复杂的处理对它们进行管理。</em></p>\n<h2><a href=\"#使用clone方法\" name=\"使用clone方法\"></a>使用Clone方法</h2>\n<p>Clone方法是Object类的方法，而我们知道所有的类的父类都是Object，所以每个类都是可以使用clone方法的。在此之前，此类需要实现Cloneable接口，否则会触发CloneNotSupportedException异常。</p>\n<pre><code>		Student clone = (Student) constructorStudent.clone();\n		clone.sayHello();\n</code></pre>\n<p>当调用一个对象的clone方法的时候，JVM会创建一个新的对象，然后将该对象的内容全部拷贝到新的对象中。需要注意的是，使用clone方法不会调用构造函数。</p>\n<h2><a href=\"#使用反序列化\" name=\"使用反序列化\"></a>使用反序列化</h2>\n<p>很早之前，在学习流的时候，有一个ObjectInputStream，在书上介绍的时候说到是序列化的时候用到的，当然了，现在整理这些知识的的时候也能够将以前的知识给串通。</p>\n<p>把对象转换为字节序列的过程称为对象的序列化。<br>把字节序列恢复为对象的过程称为对象的反序列化。</p>\n<p>java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 </p>\n<p>java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p>\n<p>为了实现序列化，需要让该类实现Serializable接口，否则会触发NotSerializableException异常。</p>\n<pre><code>		ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"data.o\"));\n		objectOutputStream.writeObject(clone);\n		objectOutputStream.close();\n\n		ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"data.o\"));\n		Student studentSerialization = (Student) objectInputStream.readObject();\n		objectInputStream.close();\n		studentSerialization.sayHello();\n</code></pre>\n<p>首先是将对象序列化，然后通过反序列化获得一个新的对象，这种方式也是不走构造器的，直接由JVM创建对象。</p>\n<h2><a href=\"#源码\" name=\"源码\"></a>源码</h2>\n<p>为了方便说明，也是直接写了几行代码。</p>\n<pre><code>package com.dimple.NewObject;\n\nimport java.io.*;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * Created by Dimple on 2018/7/22/20:04\n */\npublic class Student implements Cloneable {\n	private String name;\n\n	//含参构造器\n	public Student(String name) {\n		this.name = name;\n	}\n\n	//无参构造器\n	public Student() {\n		super();\n	}\n\n	//定义的方法\n	public void sayHello() {\n		System.out.println(\"Hello \" + name);\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	//所有异常全部抛出\n	public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, CloneNotSupportedException, IOException {\n//		1、使用new关键字创建对象\n		Student newStudent = new Student(\"小明\");\n//		调用对象的方法\n		newStudent.sayHello();\n//		2、使用Class类的newInstance方法\n		Student classStudent = Student.class.newInstance();//需要无参构造器\n		classStudent.setName(\"小明\");\n		classStudent.sayHello();\n//		3、使用Constructor类的newInstance方法\n		Constructor&lt;Student&gt; constructor = Student.class.getConstructor(String.class);//说明有参构造器的形参类型\n		Student constructorStudent = constructor.newInstance(\"小明\");//使用的是有参构造器\n		constructorStudent.sayHello();\n//		4、使用Object类的clone方法，需要实现Cloneable接口\n		Student clone = (Student) constructorStudent.clone();\n		clone.sayHello();\n//		5、使用反序列化创建对象，需要实现Serializable接口\n//		    先进行序列化\n		ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"data.o\"));\n		objectOutputStream.writeObject(clone);\n		objectOutputStream.close();\n//		    再反序列化成为一个新的对象\n		ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"data.o\"));\n		Student studentSerialization = (Student) objectInputStream.readObject();\n		objectInputStream.close();\n		studentSerialization.sayHello();\n	}\n}\n\n</code></pre>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:44:15' WHERE (`blog_id`='32');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='34', `category_id`='48', `title`='对HashMap的思考', `summary`='HashMap是一个散列表，它存储的内容是==Key-Value==键值对的映射。类原型如下：继承自抽象类AbstractMap<K,V>，实现Map接口，Cloneable主要是用于clone方法，以及序列化接口。', `status`='1', `weight`='0', `support`='1', `click`='167', `header_img`='/img/wm1.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>HashMap是一个散列表，它存储的内容是==Key-Value==键值对的映射。</p>\n<p>类原型如下：</p>\n<p>继承自抽象类AbstractMap&lt;K,V&gt;，实现Map接口，Cloneable主要是用于clone方法，以及序列化接口。</p>\n<pre><code class=\"java\">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, Serializable {\n</code></pre>\n<h1>Map的常用类型</h1><p><br></p><p>继承Map接口的有以下几种：</p>\n<ul>\n  <li>HashMap：根据键的HashCode值进行数据的存储，可以直接根据键获取值，访问速度很快。是非同步的，即线程不安全。==key和value都可以为null，但是只能有一个为null的key，value无限制。==</li>\n  <li>TreeMap：能够根据底层的红黑二叉树来对插入的数据按照==key==进行从小到大的排序。且其key不能为null，value可以为null。==key为null时，在代码编写阶段不会报错，但运行时报NullPointerException。==同时TreeMap非同步的，线程不安全。</li>\n  <li>HashTable：HashTable的key与value是不能为null，且和HashMap最大的区别是HashTable是线程安全的，其方法都是有==synchronized==关键字修饰的，其继承自==Dictionary==。但是不建议使用，因为并发不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。</li>\n  <li>LinkHashMap：采用的是链表的方式存储数据，使用Iterator进行遍历的时候，先得到的是最先插入的，即==保留了记录的插入顺序==，和HashMap的底层实现不同，导致使用LinkHashMap的时候的遍历效率比HashMap慢。同时key和value都可以为null，非同步，线程不安全。</li>\n</ul>\n<h1><a href=\"#hashmap的jdk1-6-1-7实现\" name=\"hashmap的jdk1-6-1-7实现\"></a>HashMap的JDK1.6\\1.7实现</h1>\n<p>在JDK1.6,1.7中，HashMap采用的是数组+链表的方式，即使用数组存放链表。同一个HashCode值的元素都是存储在一个链表里面，但是如果位于同一个链表的元素（就是HashCode值相等的元素）增多的时候，查找元素的时候就不能很好的发挥HashMap的功效了。</p>\n<p><img src=\"http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180809101056.png\" alt=\"enter description here\"></p>\n<p>如图：</p>\n<p>当调用map的put方法放入key-value键值对，那么首先会根据key的hashCode值，计算出在给定的key在数组中的位置，然后放在其后的单链表中。</p>\n<p>这样的设计的好处是减少了Hash碰撞，即HashCode值相同并不一定意味着对象是相同的。那么这些HashCode怎么转化为数组空间的呢？一般是hash(key)%length来得到的。</p>\n<h2><a href=\"#疑问\" name=\"疑问\"></a>疑问</h2>\n<p>1、如果多个key通过hashCode%length这样的算法得到的index都是相同的，会不会被覆盖？</p>\n<p>不会。当A通过计算得到index=1，放在链表中，如果接下来来了一个B，B通过计算得到的index也=1，那么做的事情就是使用头插法将新来的元素插入到链表的头结点。为什么使用头插法呢？可能是觉得新来的元素被查找的概率要高一点吧，毕竟查找是从头开始。</p>\n<p>2、HashMap是允许存入key-value为null的Entry的，那么他们在什么位置呢？</p>\n<p>null key总是放在entry的第一个元素。</p>\n<p>3、get操作原理</p>\n<p>get的函数原型如下：<code>public V get(Object key)</code>，先根据key的HashCode定位到数组的index，然后在这个index位置的链表进行遍历。</p>\n<h1><a href=\"#hashmap在jdk1-8的实现\" name=\"hashmap在jdk1-8的实现\"></a>HashMap在JDK1.8的实现</h1>\n<p>在JDK1.8之后，也许是意识到了当链表长度过长带来的遍历效率的问题，因此，在JDK1.8中最重要的变化之一就是引入了红黑树，当同一个hash值的节点数不小于8时，不再采用单链表形式存储，而是采用红黑树。</p>\n<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p>\n<p>有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>\n<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</p>\n<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>\n<h1><a href=\"#常用api\" name=\"常用api\"></a>常用API</h1>\n<p>| clear() | 从 Map 中删除所有映射 |<br>| remove(Object key) | 从 Map 中删除键和关联的值 |<br>| put(Object key, Object value) | 将指定值与指定键相关联 |<br>| putAll(Map t) | 将指定 Map 中的所有映射复制到此 map |<br>| entrySet() | 返回 Map 中所包含映射的 Set 视图。Set 中的每个元素都是一个 Map.Entry 对象，可以使用 getKey() 和 getValue() 方法（还有一个 setValue() 方法）访问后者的键元素和值元素 |<br>| keySet() | 返回 Map 中所包含键的 Set 视图。删除 Set 中的元素还将删除 Map 中相应的映射（键和值） |<br>| values() | 返回 map 中所包含值的 Collection 视图。删除 Collection 中的元素还将删除 Map 中相应的映射（键和值） |<br>| get(Object key) | 返回与指定键关联的值 |<br>| containsKey(Object key) | 如果 Map 包含指定键的映射，则返回 true |<br>| containsValue(Object value) | 如果此 Map 将一个或多个键映射到指定值，则返回 true |<br>| isEmpty() | 如果 Map 不包含键-值映射，则返回 true |<br>| size() | 返回 Map 中的键-值映射的数目 |</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:44:56' WHERE (`blog_id`='34');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='35', `category_id`='48', `title`='Java中的前置++和后置++的理解', `summary`='在C、C++等编程语言中都会存在i++，++i,在实际运用中我们总能记住一句话==i++(后置++)是先使用在+1，而++i(前置++)是先自增再使用==。但是在一些很烧脑的场合，这种规律就会“失效”。本文会首先简单的介绍下前置和后置++在一些场合的实际应用，可以看到的是合理的使用++会使得代码简洁不少。', `status`='1', `weight`='0', `support`='1', `click`='635', `header_img`='/img/wm1.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>在C、C++等编程语言中都会存在i++，++i,在实际运用中我们总能记住一句话==i++(后置++)是先使用在+1，而++i(前置++)是先自增再使用==。但是在一些很烧脑的场合，这种规律就会“失效”。</p>\n<p>本文会首先简单的介绍下前置和后置++在一些场合的实际应用，可以看到的是合理的使用++会使得代码简洁不少。<br></p>\n<h1><a href=\"#前置后置的实际使用\" name=\"前置后置的实际使用\"></a>++前置后置的实际使用</h1>\n<pre><code class=\"java\">package com.dimple.javabase;\n\nimport java.util.Arrays;\n\n/**\n * @program: JavaSEProject\n * @description: 测试++运算符\n * @author: Dimple\n * @create: 2018-08-14 16:46\n **/\npublic class AddOpt {\n\n	public static void main(String[] args) {\n		int i = 0;\n		String[] people = {\"Dennis Ritchie\", \"Bjarne Stroustrup\", \"James Gosling\"};\n		System.out.println(Arrays.asList(people).toString());\n		System.out.println(\"preposition ++\");\n		System.out.println(\"        before operation···\");\n		System.out.println(\"        i= \"+i);\n		System.out.println(\"        \"+people[i++]);\n		System.out.println(\"        after operation···\");\n		System.out.println(\"        i= \"+i);\n		System.out.println(\"postposition ++\");\n		i = 0;\n		System.out.println(\"        before operation···\");\n		System.out.println(\"        i= \"+i);\n		System.out.println(\"        \"+people[++i]);\n		System.out.println(\"        after operation···\");\n		System.out.println(\"        i= \"+i);\n\n	}\n}\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code class=\"java\">[Dennis Ritchie, Bjarne Stroustrup, James Gosling]\npreposition ++\n        before operation···\n        i= 0\n        Dennis Ritchie\n        after operation···\n        i= 1\npostposition ++\n        before operation···\n        i= 0\n        Bjarne Stroustrup\n        after operation···\n        i= 1\n\nProcess finished with exit code 0\n</code></pre>\n<p>上面的都是很基础的，只是单纯的为了回忆一下，所有需要记住的是：</p>\n<p>==前置++（++i）是先进行++操作后再赋值==<br>==后置++（i++）是先进行赋值再进行++操作==</p>\n<p>最近在网上看到这样一个题，本文的主要目的是这道题。</p>\n<h1><a href=\"#一道很烧脑的题\" name=\"一道很烧脑的题\"></a>一道很烧脑的题</h1>\n<p>朋友在面试的时候遇到了一道题,然后我们一起交流的时候,他把这道题给我说了下,结果我也做错了.所以在此记录下:</p>\n<p>题是这样的:</p>\n<pre><code class=\"java\">package com.dimple.javabase;\n\n/**\n * @program: JavaSEProject\n * @description: 面试题中的一道烧脑题\n * @author: Dimple\n * @create: 2018-08-14 17:00\n **/\npublic class Increment {\n	private static int k = 0;\n	public static void main(String[] args) {\n		int j=0;\n		int n=0;\n		for(int i=0;i&lt;100 ;i++){\n			j=j++;\n			k=k++;\n			n=++n;\n\n		}\n		System.out.println(j);\n		System.out.println(k);\n		System.out.println(n);\n\n	}\n}\n</code></pre>\n<p>答案出乎我的意料：</p>\n<pre><code class=\"java\">0\n0\n100\n</code></pre>\n<p>不需要去看编译后的字节码，其实很简单的就可以看出来：</p>\n<p>分析：<br>在分析之前我们还是先看一个这样的代码：</p>\n<pre><code class=\"java\">package com.dimple.javabase;\n\nimport java.util.Arrays;\n\n/**\n * @program: JavaSEProject\n * @description: 测试++运算符\n * @author: Dimple\n * @create: 2018-08-14 16:46\n **/\npublic class AddOpt {\n\n	public static void main(String[] args) {\n		int j=0;\n		 j = j++;\n		System.out.println(j);\n	}\n}\n</code></pre>\n<p>以上代码如果我们使用的是IDEA编译器的话，在j下面有一个小波浪线提示以下话：</p>\n<blockquote>\n  <p>The value changed at ‘j++’ is never used less… (Ctrl+F1)<br>Inspection info: This inspection points out the cases where a variable value is never used after its assignment, i.e.: &nbsp;- the variable never gets read after assignment OR &nbsp;- the value is always overwritten with another assignment before the next variable read OR &nbsp;- the variable initializer is redundant (for one of the above two reasons)</p>\n</blockquote>\n<p>以上提示说的是：该j变量并没有被使用。emmmmm不是让它=j了吗？以上只是一个小的插曲，接下来开始我们的分析。</p>\n<p>首先我们看到==j=j++;==这样的一句话，本身是有问题的（为了说明，我们把表达式左边的j叫做j1，右边的j叫做j2（注意，只是叫做！））：<br> 1. 执行时，首先是会执行等号右边的话，也就是==j1=j2==这一句话，那么这样的一句话，得到的结果是j1=0，对吧。<br> 2. 这个时候如果按照正常的逻辑，那么应该是执行j++这句话了对吧。是这样没错，肯定是会执行j++这一句话的。注意：执行这个j2++的时候，并不和j1在同一个工作区，j2++完了之后，并没有任何的变量去接收它。导致j2++废弃。所以j一直都是0.</p>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>–操作符同理，其实细致点这个问题是可以看出来的，还是需要修炼基本功呀···</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:45:38' WHERE (`blog_id`='35');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='36', `category_id`='48', `title`='Java读取Properties文件的几种方式', `summary`='在Spring的时候，通过XML配置文件的方式进行配置数据库连接池的时候，就会使用==context:property-placeholder==标签进行读取，在这里呢，也是通过Java几种比较基础的方式来读取Properties文件。在开始之前，说下目前比价常用的几种方式：1. 使用java.util.Properties类,可以使用它的load方法加载inputStream字节流。2. 使用java.util.ResourceBundle类来读取。', `status`='1', `weight`='0', `support`='1', `click`='184', `header_img`='/img/wm1.png', `type`='2', `content`='<p><br></p>\n<h1><a href=\"#前言\" name=\"前言\"></a>前言</h1>\n<p>在Spring的时候，通过XML配置文件的方式进行配置数据库连接池的时候，就会使用==context:property-placeholder==标签进行读取，在这里呢，也是通过Java几种比较基础的方式来读取Properties文件。</p>\n<p>在开始之前，说下目前比价常用的几种方式：<br> 1. 使用java.util.Properties类,可以使用它的load方法加载inputStream字节流。<br> 2. 使用java.util.ResourceBundle类来读取。<br></p>\n<h1><a href=\"#使用properties类\" name=\"使用properties类\"></a>使用Properties类</h1>\n<p>Properties类继承自Hashtable，而Hashtable是实现了Map接口的，所以对Properties类的操作和Map有些相似。</p>\n<p>使用Properties来加载.properties文件的主要关键是在于load方法。而load方法需要的是InputStream流。</p>\n<p>这里比较常用的流的获取有以下几种：</p>\n<ol>\n  <li>使用当前类的ClassLoader()的getResourceAsStream()，getResourcesAsStream返回一个InputStream。</li>\n  <li>使用ClassLoader类的getSystemResourceAsStream()，该方法也返回一个InputStream。</li>\n  <li>使用文件输入流的方式。</li>\n</ol>\n<p>具体示例如下，为了方便，我直接使用的log4j.properties。</p>\n<pre><code class=\"java\">/**\n	 * 单独抽取的方法，用户检测能否正确操纵Properties\n	 *\n	 * @param inputStream\n	 * @throws IOException 为了排版美观，直接抛出异常\n	 */\n	public void printKeyValue(InputStream inputStream) throws IOException {\n		Properties properties = new Properties();\n		properties.load(inputStream);\n		Set&lt;Object&gt; keys = properties.keySet();\n		for (Object key : keys) {\n			System.out.println(key + \" = \" + properties.get(key));\n		}\n	}\n\n	/***\n	 * 从当前的类加载器的getResourcesAsStream来获取.\n	 * 使用Class.class.getClassLoader().getResourcesAsStream()进行获取的时候，所填写的路径只能为项目的绝对路径\n	 * @throws IOException\n	 */\n	@Test\n	public void getPropertiesFromResourceAsStream() throws IOException {\n		InputStream resourceAsStream = PropertiesUtils.class.getClassLoader().getResourceAsStream(\"com/dimple/getproperityfile/mylog4j.properties\");\n		printKeyValue(resourceAsStream);\n	}\n\n	/***\n	 * 从文件中获取,使用InputStream字节\n	 * 主要是需要加上src这个文件夹名。。。路径配置需要精确到绝对地址级别\n	 * 什么意思，就是如果这个mylog4j文件在com/dimple/getproperityfile/mylog4j.properties下，而这个com文件夹\n	 * 又在src目录下，那么写的时候需要加上这个src，这样的相对路径+项目地址能够构成一个完整的访问地址即可\n	 * @throws IOException\n	 */\n	@Test\n	public void getPropertiesFromFile() throws IOException {\n		InputStream inputStream = new FileInputStream(new File(\"src/com/dimple/getproperityfile/mylog4j.properties\"));\n		printKeyValue(inputStream);\n	}\n\n	/**\n	 * 使用Class类的getSystemResourceAsStream方法\n	 * 和使用当前类的ClassLoader是一样的\n	 *\n	 * @throws IOException\n	 */\n	@Test\n	public void getPropertiesFromClassLoader() throws IOException {\n		InputStream systemResourceAsStream = ClassLoader.getSystemResourceAsStream(\"com/dimple/getproperityfile/mylog4j.properties\");\n		printKeyValue(systemResourceAsStream);\n	}\n</code></pre>\n<h1><a href=\"#使用resourcebundle类\" name=\"使用resourcebundle类\"></a>使用ResourceBundle类</h1>\n<p>使用ResourcesBundle类也两种方法可以读取到配置文件</p>\n<ol>\n  <li>使用类ResourcesBundle的getBundle方法加载properties文件。</li>\n  <li>使用其派生类PropertyResourceBundle()，通过传入一个InputStream来读取数据。</li>\n</ol>\n<p>代码如下：</p>\n<pre><code class=\"java\">/***\n	 * 使用java.util.ResourceBundle类来加载properties文件，注意不需要带上后缀名。\n	 */\n	@Test\n	public void getPropertiesFromResourceBundle() {\n		ResourceBundle resourceBundle = ResourceBundle.getBundle(\"com/dimple/getproperityfile/mylog4j\");\n		Enumeration&lt;String&gt; keys = resourceBundle.getKeys();\n		while (keys.hasMoreElements()) {\n			String s = keys.nextElement();\n			System.out.println(s + \" = \" + resourceBundle.getString(s));\n		}\n	}\n\n	/**\n	 * 使用InputStream流来进行操作ResourceBundle，获取流的方式由以上几种。\n	 * @throws IOException\n	 */\n	@Test\n	public void getPropertiesFromResourceBundleInputStream() throws IOException {\n		InputStream systemResourceAsStream = ClassLoader.getSystemResourceAsStream(\"com/dimple/getproperityfile/mylog4j.properties\");\n		ResourceBundle resourceBundle = new PropertyResourceBundle(systemResourceAsStream);\n		Enumeration&lt;String&gt; keys = resourceBundle.getKeys();\n		while (keys.hasMoreElements()) {\n			String s = keys.nextElement();\n			System.out.println(s + \" = \" + resourceBundle.getString(s));\n		}\n	}\n</code></pre>\n<h1><a href=\"#总结\" name=\"总结\"></a>总结</h1>\n<p>以上代码的的方法具体有什么用已经表明了，遇到的问题已经不是代码问题了。而是路径。对于这个路径，相对路径，绝对路径，项目路径，这个路径确实让我有些头痛，在File的Test代码哪里，文件路径近乎是我试出来的。当然读者可能会说，直接拿鼠标去点，能点进去的就是对的，但是，在File那里，我没有加src，是可以点击去的，但是项目报错提示FileNotFound，加上src就能正常访问，但是点不进去。这个原因是因为IDEA这里，有一个工程路径的说法，工程路径并不包含src，而代码是写在src下的，所以导致最后的绝对路径不可达，所以报错。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:46:09' WHERE (`blog_id`='36');
UPDATE `dimple_blog`.`bg_blog` SET `blog_id`='40', `category_id`='48', `title`='Java中接口和抽象类', `summary`='经常看到关于Java中的接口和抽象类的比较，看着这两难兄难弟确实还是有些像，又有些不想，借此，想好好总结下他们两。', `status`='1', `weight`='0', `support`='1', `click`='175', `header_img`='/img/wm1.png', `type`='2', `content`='<p><span style=\"color: inherit; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 36px;\">前言</span><br></p>\n<p>经常看到关于Java中的接口和抽象类的比较，看着这两难兄难弟确实还是有些像，又有些不想，借此，想好好总结下他们两。</p>\n<h1><a href=\"#关于抽象类\" name=\"关于抽象类\"></a>关于抽象类</h1>\n<p>在Java中，抽象类是以abstract关键字修饰的。有抽象方法的一定是抽象类，反之，抽象类不一定有抽象方法，这句话是《Java编程思想》这本书中提到的，说的是只要是被关键字abstract修饰的类都叫抽象类，而不管这个类中是否含有抽象方法。抽象类的定义格式为：</p>\n<pre><code>abstaract class ClassName{}\n</code></pre>\n<p>抽象方法： 抽象方法是一种特殊的方法，只有方法的声明，但是没有方法的实现。抽象方法的声明格式为：</p>\n<pre><code> abstract void function();\n</code></pre>\n<p>抽象类是为了继承而存在的，抽象出子类共有的一些特点，然后交给其具体的实现。</p>\n<p>抽象类并不一定包含抽象方法，它和普通的类一样，也是可以拥有成员变量和普通的成员方法。</p>\n<p>抽象类和普通的类的三点区别：<br>* 抽象方法必须为public或者protected，缺省默认为public。</p>\n<ul>\n  <li>\n  <p>抽象方法不能用来创建对象。</p></li>\n  <li>\n  <p>如果一个类继承自一个抽象类，那么需要实现这个类的所有方法，如果没有实现这个类的所有方法，那么该类也需要被定义为abstract。<br><img src=\"http://p2sj58chj.bkt.clouddn.com/TIM截图20180801205707.png\" alt=\"TIM截图20180801205707\"></p></li>\n</ul>\n<p><strong>另外抽象类是可以有构造器的。</strong></p>\n<h1><a href=\"#关于接口\" name=\"关于接口\"></a>关于接口</h1>\n<p>接口（interface）是对行为的抽象。在java 中定义一个接口的方式如下：</p>\n<pre><code>interface InterfaceName{}\n</code></pre>\n<p>接口中可以含有方法和变量。其中变量会被隐式的指定为public final static 类型。其中的方法会被隐式的指定为public abstract，且不能有方法的实现（“Interface abstract methods cannot have body”）。</p>\n<p>实现一个接口需要用到implements关键字</p>\n<pre><code>class ClassName implements InterfaceA,InterfaceB{}\n</code></pre>\n<p>一个类可以实现多个接口。如果一个抽象类implements某个接口，可以不实现这个接口中的方法。非抽象类implements某个结构就必须要实现该接口中的所有方法。</p>\n<h1><a href=\"#抽象类和接口的区别\" name=\"抽象类和接口的区别\"></a>抽象类和接口的区别</h1>\n<p>区别之处：</p>\n<p>1、接口中的所有方法都是隐含的abstract的，而抽象类亦可以同时包含抽象和非抽象的方法。</p>\n<p>2、一个类可以实现很多接口，但是只能继承自一个抽象类。</p>\n<p>3、类可以不实现抽象类和接口中的所有方法，这种情况下的类需要被声明为abstract。</p>\n<p>4、接口中的变量都是被默认声明为public static final的，而抽象类中的成员变量可以是各种类型的。</p>\n<p>5、Java接口中的成员函数默认都是public的，抽象类中的成员函数可以是private、protected、public的。</p>\n<p>其他：</p>\n<p>1、接口是可以被接口继承的，通过extends关键字声明一个接口是一个接口的子接口，由于接口中的方法和常量都是public的，子接口将继承胡接口的全部方法和常量。</p>\n<p>2、抽象类可以继承自实体类。</p>', `create_by`=NULL, `create_time`='2019-01-30 00:00:00', `update_by`='admin', `update_time`='2019-04-02 15:46:41' WHERE (`blog_id`='40');


